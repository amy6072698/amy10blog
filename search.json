[{"title":"2024 六角前端工程師體驗營心得","url":"/amy10blog/2024/06/09/20240609_reflections_on_learing_hexschool/","content":"如何認識六角？其實一開始對前端感興趣是在前年，做了很多調查看到一篇部落格文章特別寫到六角學院是很棒的學習環境，有助教老師不會排斥新手問問題，才下定決心先買了六角學院的影音課程\n在前年年底工作繁忙期終於告一段落時，才開始看影音教學學了一陣子，但這時候的我還不太敢在 Discord 群組問問題，一是覺得不太熟悉 Discord 操作用起來怕怕的，二是覺得跟六角的助教同學不太熟就一直問感覺怪怪的，所以學習起來一直有種孤單、無力的感覺\n因為無力感一度走錯路在今年年初這種學習上的無力感和孤單感讓我決定： 要不然換一個學習平台試試看？\n於是我轉而找到了另一家也是線上的學習平台，他們有開前後端的教學系列課，都是線上影音課，同樣有助教跟 LINE 顧問可以問問題\n但是事情沒這麼簡單\n影片是 4 年前的教學影片：影片下方沒有備註新的操作內容\n\n助教老是不知道你在問什麼：跟他說影片幾分幾秒錄影有缺漏，他反問我有沒有看影片？\n\nLINE 顧問只會像鬧鐘一樣過沒幾天問你進度如何：專業問題顧問不會所以沒辦法解答，我只想問我就是卡住了要怎麼有進度？\n\n\n結果最後問題不是助教、也不是顧問幫忙解決的，是一個印度人解決的！\n沒錯！是我去網路上找了兩天資料，最後看到一個印度人的教學影片解決的，我就這樣花了十幾萬到這種平台自己找罪受，當我決定要退費時已經來不及了，因為已經看超過可以退費的影片進度了，當我再次回過頭仔細觀察這個所謂專業的前後端學習平台，他們教出的學員做出什麼作品時，那作品的程度…我覺得面試官是不可能會錄取的\n反正都走投無路了就再相信一次了解這個平台根本只想賺錢，不是真心想要輔導學員做出好作品、讓學員順利轉職之後，我決定果斷放棄那個有毒的學習環境，再一次尋找一個能夠讓我好好學習順利轉職的平台\n就在已經對線上學習平台心灰意冷的時候，我的臉書跳出六角學院的體驗營報名資訊，點進去之前我還想著：「是不是又是一個騙錢不想認真輔導學員的學習平台」，結果看見價格時…我只覺得他們瘋了！\n原本預計明年要轉職，結果遇到前一個學習平台打壞所有原定計畫，我想著 敢用這麼瘋的價格開一個月的體驗營課程，反正我也走投無路了就跟他拚了、跟他一起瘋，就這樣我報名了 2024 年六角學院的體驗營\n徬徨過最後才會選擇跟六角一起前進參加了這一個月的體驗營，我很高興瘋了那一次，再次相信六角學院真的是願意輔導學員讓學員能順利轉職的學習平台，這一個月每天都很累但是看見自己的作品、組員間討論做作業，都讓 我感覺對前端的學習終於上軌道了\n當然上完體驗營只是開始，不過要我選擇一起學習一起前進的夥伴的話，一定非六角莫屬！\n在體驗營中因為知道很多人是新手所以更容易在 Discord 群組發問，小組組員背景很相近可以互相勉勵一起想出問題的解決方法，跟自己之前孤軍奮戰相比多了幾分團戰打怪的熱血，真的很喜歡這種學習氣氛\n所以我決定繼續跟著六角學習前端，最後祝跟我一樣想轉職的六角夥伴都能轉職成功！\n讓我們一起打怪、一起前進！\n","categories":["心得分享"],"tags":["前端","心得分享"]},{"title":"如果不試一輩子都不知道自己能走這麼遠｜不知不覺寫了 1 年程式，前端工程師修煉之路","url":"/amy10blog/2025/04/15/20250415_reflections_on_learing_frontend/","content":"報名緣起自從動了想轉職前端的念頭，怎麼動念的有緣再說 XDD\n就開始上網瘋狂找前端學習資源，但始終不知道從何下手，後來看了一篇分享文章，發現我需要更系統化的學習所以購買六角學院的影音課程\n但發現只是看影片學習成效不佳，自己摸索需要很多時間，中間曾嘗試其他單位，但課程內容過舊學習反而更吃力 (要花更多時間除錯\n去年 4 月正當迷茫之際 去找牙醫定期洗牙時 (這不是重點 ，一則臉書廣告讓我決定再試一次，於是我報名了 2024 年的前端工程師體驗營 (在報名截止最後一天\n上完體驗營之後我發現自己不排斥寫程式 (反而喜歡上寫程式破解問題的過程，就這樣我毅然地踏上 六角學院長達 9 個月 的前端工程師修煉取經之路\n廢話少說上表\n接下來就來說說經歷 9 個月修鍊過關斬將的心得吧~ (放一隻悟空加持🐵\n\n團隊合作的重要 (組隊去取經作者我並不是本科系上完體驗營決定要轉職時，說不害怕是假的，但 不被認同比自己能力不足更讓我害怕 ，畢竟能力可以靠進修跟實作來補足，自信卻會因為一直不被認同而消磨，這樣取經之路會更艱難\n你也許會說非本科轉職本來就容易不被認同啊~ (沒錯，所以才要找一個正面積極的學習環境，可以選當然就要選能支持自己撐下去進修的環境，以免好不容易燃起的進修魂被別人一桶水澆滅\n六角會依照問卷調查結果，將程度、背景差不多的學員分在一起組隊打怪，所以進修過程中我不用擔心沒人認同，我的隊友跟我一樣 (是悟空🐵 選了同樣的路\n\n只是後續 團隊的時間管理、隊友積極度、與隊友的溝通，這些都與隊友程度背景相不相符無關，但卻會影響專案開發進度的關鍵，在這段與團隊一起開發專案的過程中 「當團隊出現狀況該如何應對」 是很重要的課題\n\n團隊合作的好處是比一個人走走更遠一個人進修是很孤單、無助的，一群人互相幫助分工讓專案更完善，有隊友就能在專案開發或實作練習卡關時，提出來問題大家一起破關 (打怪，有時候真的就被我們這群臭皮匠找到網路大神的破解法了\n在這段團隊合作的過程中我 學會如何跟隊友溝通合作，也 了解到互相配合、互相扶持、互相努力才能完成最終專案開發的成果，即使培訓課程已經結束我們也持續在交流不錯的技術學習資源，並持續優化我們的專案\n\n最終 Boss 關： React 作品實戰班經歷長達 9 個月的前端工程師培訓迎來最終 Boss 關，是最後一環，也是最重要的一環\n必須和團隊完成一個 React 專案，而且看看前面的時程表，我必須兼顧 React 直播班的學習進度，並把學到的技術用在專案開發上\n初學 React 很艱難，學習過程中不斷考驗我的 JavaScript 基礎， 遇到困難怎麼辦？利用各種資源想辦法解決呀！ 六角的學習資源、六角教練跟助教、網路上其他大神的破解法等\n無論如何向前跑就對了！直播班每週都有作業，沒趕上進度等團隊討論完專案主題 (就變成夾心餅乾餡了，當然六角也很怕學員不交作業影響開發進度，所以會提供各種資源讓你救自己\n\n不輕易放棄才是我最大的收穫不過就算六角有資源不努力利用也沒用，過程中聽說就有不少人放棄完成專案開發，我很高興我能破除萬難堅持撐下去，既然選了轉職我就要走下去\n也因為撐下去了才能學會更多技術，學會碰到困難要想辦法找解方，這樣 不輕易放棄的態度 是我這段時間進修得來的最大收穫\n好幾次學習 React 的過程，我也曾懷疑自己能不能和隊友開發完專案的主要功能，但我就是不想放棄，都撐這麼久了，剩下最後一段路為什麼不走完？\n\n如果不試一輩子都不知道自己能走這麼遠從想轉職而開始嘗試寫程式，到發現自己不排斥，再到最後持續進修開發出專案，這之中每一步都很重要，但我想踏出第一步很關鍵 沒有第一步哪來下一步\n出了社會我不斷嘗試找到感興趣的領域，忘了說我本科是外語相關的，因為我知道外語始終是工具總要找到一技之長，不然就等著被取代，尤其時代進步很快，學習新技術無可避免，只能持續進修增加技能提升價值\n而為了找到我真正想做的事，從畢業後就一直嘗試進修任何感興趣的領域，就這樣嘗試上了六角的前端工程師體驗營，才確定自己真的想往這條路走\n現在回頭看才發現自己已經持續學習前端技術 1 年了，團隊專案也開發完成，如果我當時沒有試，我想我一輩子都不知道自己能走這麼遠\n最後很感謝我的隊友和六角的老師、專題教練、助教們，你們是我撐下去的助力 (想放棄時看到隊友也撐得很痛苦不知為何就又想撐下去了🤣，後續團隊專案如果學了新技術可以持續優化\n\n這篇文章主要是分享自己進修前端工程師的心得，未來也會把一些遇到的開發問題或自己學習的筆記寫成文章分享\n期待與大家再次空中再會啦~~~\n","categories":["心得分享"],"tags":["前端","心得分享"]},{"title":"從零開始學 Hexo (2) | Hexo 安裝方法","url":"/amy10blog/2025/04/22/20250422-hexo-learning2/","content":"想了解 Hexo 從官網開始想知道怎麼安裝 Hexo，第一站就是 Hexo 的官網 ，進入官網後點上方導覽列的「文件」:\n\n然後你就可以看到 Hexo 很貼心的把安裝方式放在文件的第一頁囉 ~\n\n往下滑你可以看到更多關於 Hexo 安裝需要的東西：\n\n首先安裝需求的部分會需要先安裝 Node.js 和 Git，先從 Node.js 的安裝開始\n\n安裝 Node.js如果你曾經看過以前的文章講解如何安裝 Node.js，那你就會看見以下這張圖，它有兩種下載按鈕，一個是 LTS 版本、一個是 Current 版本\n\n這兩種版本差異簡單講就是 LTS (Long-term support) 長期支援版是當前穩定的版本，Current 則是最新版本，一般如果不是為了最新功能不會去下載 Current 版，所以這邊就下載 LTS 版本就可以囉 ~\n不過現在官網已經改成只有 LTS 一個按鈕了，所以上面說明就當作是小補充吧，把那唯一的下載按鈕揍下去就對了\n\n下載完成之後你的下載資料夾會出現 Node.js 的安裝檔，點兩下開啟檔案然後按 Next 按鈕、勾選同意，然後一路按 Next 按鈕最後再按下 Install 按鈕就可以完成安裝了\n如果你按安裝過程中沒有指定位置，安裝完之後的 Node.js 一般會在本機的 Program Files 資料夾中：\n\n\n安裝 Git要安裝 Git 就先進入它的官網，進入後往下滑會看見一台小電腦在畫面上，它會判斷你是 Windows 還是 Mac 系統，按下下載按鈕：\n\n然後官網會跳轉下載頁面，並自動下載，若沒有自動觸發，可點擊下圖 Click here to download 連結手動下載：\n\n下載完成之後你的下載資料夾會出現 Git 的安裝檔，一樣點兩下開啟檔案，再來就是按肯定的按鈕 (說 Yes 就對了 ，然後按下安裝，這樣就完成安裝囉 ~\n\n安裝 Hexo 前先檢查再來就要開啟終端機檢查有沒有成功安裝好 Node.js 和 Git 了，開啟終端機後輸入以下指令如果系統都有回應你剛剛安裝的版本號碼就表示你正確完成安裝囉 ~\n檢查是否安裝 Node.jsnode -v\n\n檢查 npm 是否正常npm 是 Node.js 預設的軟體套件管理系統，會隨著 Node.js 安裝時一起安裝，因為之後會透過 npm 進行 Hexo 的安裝，所以一定要確保 npm 有正常安裝\nnpm -v\n\n檢查是否安裝 Gitgit --version\n\n\n安裝 Hexo終於進入安裝 Hexo 的階段啦~~~ 確認以上軟體安裝完成後，接下來依照官網的安裝指示，執行以下指令就可以透過 npm 來安裝 Hexo 囉 ~\nnpm install -g hexo-cli\n\n檢查 Hexo 是否安裝成功接下來別忘記檢查 Hexo 是否安裝成功，執行以下指令，如果有成功跑出版本號碼，那麼就恭喜你成功安裝好 Hexo 囉🎉\nhexo -v\n\n\n你可能會遇到 PowerShell 執行原則問題如果你是使用 Windows 系統的 PowerShell 為執行指令的終端機，或你是開 VSCode 內的終端機(VSCode 預設使用的終端機是 PowerShell)，那在安裝時你可能會遇到 PowerShell 的執行原則問題 (提前說以免有人再掉到坑裡，維護安全人人有責\n情況說明當你執行指令打算美美的完成 Hexo 安裝時，發現它回了一串錯誤給你，有可能長得像這樣：\nhexo : 因為這個系統上已停用指令碼執行，所以無法載入 ...\n\n講一堆就是不給你安裝的意思，那有可能是 PowerShell 的執行原則產生的問題， Windows 預設的 powershell 執行原則為 Restricted\n PowerShell 有四種執行原則：\n\nRestricted：所有 PowerShell Script(.ps1) 皆無法執行(Windows系統預設)\nAllSigned：所有 PowerShell Script 都要經過受信任的發行者簽屬過後才可執行\nRemoteSigned：針對從異地下載下來的 PowerShell Script 需要經過受信任的發行者簽屬過後才可執行，本機的 PowerShell Script 可直接執行\nUnrestricted：無限制，所有 PowerShell Script 皆可執行\n\n解決方法想解決前面出現的錯誤其實只要改變執行原則的設定即可，但在改變之前要先執行以下指令確認 PowerShell 現在是哪個執行原則：\nget-executionpolicy\n\n如果它回 Restricted，再往下執行以下指令，執行後會有視窗詢問，按下確定後就能將執行原則改為 Remotesigned\nset-executionpolicy remotesigned\n\n但如果不幸還是跳出錯誤，長得像這樣：\nSet-ExecutionPolicy : 拒絕存取登錄機碼...\n\n那就再往下執行以下指令，就能成功執行了：\nSet-ExecutionPolicy -Scope CurrentUser RemoteSigned\n\n希望大家還是不要踩到坑比較好，如果不幸遇到的話希望這個問題補充可以幫助到你，以上內容參考自CC的技術隨筆 VSCode 執行 npm install 失敗文章，想了解更詳細內容可以去看看\n那就先祝大家都順利安裝 Hexo 成功囉 ~ 我們下篇文章見🪄\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (4) | 新增 Hexo 文章與常用 Markdown 語法","url":"/amy10blog/2025/04/24/20250424-hexo-learning4/","content":"前置說明自己是習慣使用 VSCode 來編輯程式碼，所以之後的程式碼都會以 VSCode 畫面做示範，如果你也想使用 VSCode ，可以到 VSCode 官網 進行下載安裝，安裝細節大家可以參考 社長(Sajhon)這篇文章\n如何建立你的 Hexo 部落格文章經過前篇介紹執行 hexo server 指令可以開啟 Hexo 伺服器，在本地看到目前部落格的樣子後，你一定迫不及待想要開始寫自己的文章了，接下來就來介紹新增文章的 Hexo 指令吧 ~\n先用 VSCode 開啟你的 Hexo 部落格資料夾 ( Hexo 幫你建的那個資料夾) ，以我在前篇的示範為例就是 amy10blog 資料夾\n再來在視窗上方檢視旁邊有三個點按下去，選終端機 &gt; 新增終端機，就可以在 VSCode 中開啟終端機了，此時終端機會直接在目前開啟資料夾的路徑上，也就是你的 Hexo 部落格資料夾路徑上\n確定終端機在你的 Hexo 部落格資料夾路徑上後，再執行以下指令，你的文章名稱 可以自己取名 (注意：名稱要用單引號 &#39;&#39; 包住)\nhexo new &#x27;你的文章名稱&#x27;\n\n下完指令後，在 source 資料夾裡面的 _post 資料夾中，Hexo 會新增一個 .md 檔，以 你的文章名稱 命名，假設文章名稱叫 hexo_learning1 執行結果如下：\n\n小補充： VSCode 開啟終端機快捷鍵是 ctrl + shift + 反引號鍵 (就是 tab 上面有小蚯蚓 ~ 的那個鍵)\n\n怎麼用 Markdown 語法撰寫文章？如果你有仔細研究 Hexo 官網的文件，你應該會發現在文件第一頁，官方就有解釋：\n\nHexo 是一個快速、簡單且強大的網誌框架。  Hexo 使用 Markdown（或其他標記語言）解析您的文章 ，並在幾秒鐘內，透過漂亮的主題產生靜態檔案。\n\n沒錯，建立完文章後你還需要學習一些 Markdown 語法，才能寫出有不同文字樣式效果的文章，接下來就介紹一些我自己比較常使用的 Markdown 語法給大家參考囉 ~\n\n標題在文字開頭加上井字號 # ，以下是程式碼示範，標題 1 ~ 6 對應 HTML 的  &lt;h1&gt; ~ &lt;h6&gt; 標籤樣式\n# 標題1## 標題2### 標題3#### 標題4##### 標題5###### 標題6\n\n示範：\n標題1標題2標題3標題4標題5標題6粗體將文字用 2 個星號 ** 包住，對應 &lt;strong&gt; 標籤樣式\n我是 **粗體** 文字\n\n示範：我是 粗體 文字\n斜體將文字用 1 個星號 * 包住，對應 &lt;em&gt; 標籤樣式\n我是 *斜體* 文字\n\n示範：我是 斜體 文字\n刪除線將文字用 2 個小蚯蚓 ~~ 包住，對應 &lt;s&gt; 標籤樣式\n我是 ~~刪除線~~ 嘿嘿\n\n示範：我是 刪除線 嘿嘿\n分隔線在行與行之間加上 3 個減號 --- 或星號 ***，對應 &lt;hr&gt; 標籤樣式，建議以減號代替米字號，閱讀上較為方便\n我在減號分隔線之上哈哈哈---我在減號分隔線之下嗚嗚嗚我在星號分隔線之上哈哈哈*** 我在星號分隔線之下嗚嗚嗚\n\n示範：我在減號分隔線之上哈哈哈\n\n我在減號分隔線之下嗚嗚嗚\n我在星號分隔線之上哈哈哈\n\n我在星號分隔線之下嗚嗚嗚\n插入連結一種由中括號 [] 和小括號 () 組成，中括號內寫入連結文字的內容、小括號內寫入連結網址；另一種是直接用大於小於符號 &lt;&gt; 包住連結網址，兩種方式都對應 &lt;a&gt; 標籤樣式\n[點我前往異空間](https://amy6072698.github.io/amy10blog/123)&lt;https://www.google.com/&gt;\n\n示範：點我前往異空間https://www.google.com/\n插入圖片和連結寫法大致相同，但需要在中括號 [] 前面加入一個驚嘆號 ! ，中括號內寫入圖片說明文字，小括號內寫入圖片連結，對應 &lt;img&gt; 標籤\n以下圖片來源\n![賣萌的貓咪圖](https://images.unsplash.com/photo-1589883661923-6476cb0ae9f2?q=80&amp;w=200&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)\n\n示範：\n\n清單清單分為有序清單與無序清單，兩種寫法不同\n 有序清單 ：寫法是阿拉伯數字加點 . 加空白之後，再接項目文字，對應 &lt;ol&gt; &gt; &lt;li&gt; 標籤樣式\n1. 項目一2. 項目二\n\n示範：\n\n項目一\n項目二\n\n 無序清單 ：寫法有三種，用星號 * 或加號 + 或減號 - 其中一種符號，加空白之後再接項目文字，對應 &lt;ul&gt; &gt; &lt;li&gt; 標籤樣式，雖然三種符號都可以，但建議同篇文章的無序清單，統一用一種符號撰寫方便閱讀\n* 星號項目一* 星號項目二+ 加號項目一+ 加號項目二- 減號項目一- 減號項目二\n\n示範：\n\n星號項目一\n星號項目二\n\n\n加號項目一\n加號項目二\n\n\n減號項目一\n減號項目二\n\n引用在引用文字的開頭加上大於符號 &gt; ，就會產生 &lt;blockquote&gt; 標籤的樣式，但不要因為想要這種樣式的文字就貿然使用，因為這個標籤代表引用的意思請謹慎使用\n&gt; 我是從別處引用的文字，你好呀！\n\n示範：\n\n我是從別處引用的文字，你好呀！\n\n程式碼要在文章內加入程式碼，有兩種方式一種是程式碼片段、一種是程式碼區塊\n 程式碼片段 ：將程式碼用 1 個反引號 (跟小蚯蚓 ~ 同一個鍵) 包住\n程式碼的左邊 `let a = 1;` 程式碼的右邊\n\n示範：程式碼的左邊 let a = 1; 程式碼的右邊\n 程式碼區塊 ：在程式碼上一行加上 3 個反引號加程式碼語言縮寫，下一行則只加上 3 個反引號結尾，這樣會在程式碼塊內產生不同程式碼語言的高亮樣式，通常會透過 highlight.js 套件產生高亮樣式\nMarkdown 寫法：\n\n以下以 HTML 、 CSS 、 JS 示範：\n&lt;h2&gt;我是標題&lt;/h2&gt;\n\n.box &#123;  background-color： red;&#125;\n\nlet a = 1;\n\n\n試著做做看看完以上 Markdown 語法寫法，可以試著在你新增的文章 .md 檔中寫入內容，完成後記得儲存 (這很重要) ，再用 hexo server 開啟 Hexo 伺服器看看你的文章內容是否正確顯示喔 ~\n\n一開始點開連結會在首頁，你剛新增的文章名稱會出現在首頁 Recent Posts 的區塊\n\n點一下你剛剛新增的文章名稱，就會看到你新增的文章內容囉 ~\n\n\n結語其實文章中介紹的 Markdown 語法並非全部，還有很多細節可以了解，如果想了解更多可以參考 Ray 的 Markdown 基礎與入門教學手冊 ，這篇只有就我自己比較常使用的語法作介紹，希望經過這篇文章大家可以寫出美美的 Hexo 部落格文章，那我們下篇文章見 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (6) | 認識 Hexo 目錄與調整全站網站設定","url":"/amy10blog/2025/04/26/20250426-hexo-learning6/","content":"認識 Hexo 目錄結構在開始講解如何部署你的部落格網站之前，我們先簡單認識一下 Hexo 資料夾內的目錄結構吧！什麼？你說為什麼？看下去就知道啦 ~\n還記得一開始下 Hexo 指令的時候嗎？對的，就是你下了一個像 hexo init 你的網站英文名稱 這樣的指令，然後 Hexo 就咻的把一個 Hexo 部落格資料夾丟進你的專案資料夾裡了\n前面一直都沒有細談 Hexo 給的這個部落格資料夾裡面到底有什麼，接下來就簡單說明裡面的內容，以我的部落格資料夾為例，裡面有這麼多資料夾及檔案，接下來就簡單講解幾個資料夾及檔案的作用吧 ~\n\nnode_modules裡面會存放很多很多 ( 多到無法想像 ) 專案 ( 你的部落格網站 ) 所需的所有套件資料，所以它通常不會被加入 git 的版本控制，就不會被 push 傳到遠端的 GitHub 儲存庫\n假設這個專案需要和別人協作開發，對方把資料 git clone 下來 (從遠端 GitHub 儲存庫抓下來)，而抓下來的資料當然不會有 node_modules ，不過只要執行 npm intsall 指令，就會自動產生 node_modules 這個資料夾了\n所以就不需要把藍鯨 ( node_modules ) 冰到小冰箱裡了，可以多冰幾顆布丁\n如果你對 git 還不了解，可先忽略不懂的部分，只要知道 node_modules 是用來放你的部落格網站所有所需套件的資料夾就好\nscaffolds這個資料夾裡有下 Hexo 指令生成草稿、頁面及文章的預設模板檔案，分別是 draft.md、page.md、post.md\n\n還記得前篇提到的，文章開頭可以寫入 tags 嗎？\n假設我希望每次下 hexo new &#39;文章名稱&#39; 指令產生的文章檔，都要在文章開頭加 description 項目，就要改 post.md 這個檔案，像這樣：\n\n這樣下次執行 hexo new &#39;文章名稱&#39; 指令，文章開頭就會多出 description 囉 ~\n順便補充生成草稿的 Hexo 指令：hexo new draft ( 雖然我比較少用 )\nsource再來我們目前最熟悉的 source 資料夾 ~ 前面講到你的部落格文章、頁面檔案都會放在這個資料夾\nthemes這個資料夾會用來放安裝下來的 Hexo 樣板主題資料，看到資料夾名稱有 s 對嗎？沒錯，是複數這表示它可以放不只一種主題，至於 Hexo 如何更換主題之後會再講解 ( 保留點神祕感 )\n_config.yml (全站)奇怪這個檔名？好眼熟！眼熟就表示你前篇有認真看👏\n沒錯，前篇有提到 themes 的 landscape 資料夾內也有一個 _config.yml 檔，但是和這裡的 _config.yml 檔當然是不同的，這就是為什麼要先認識 Hexo 目錄的原因\n這裡的 _config.yml 檔網站全站的設定檔，不是主題的設定檔，也就是當你需要調整一些全站設定時，就會來這裡修改這個全站的 config 檔\n為了避免誤會先定義好兩者的名稱，接下來 themes 的 _config.yml 檔，我會叫「主題的 config 檔」，這個全站的 _config.yml 檔，就叫「全站的 config 檔」\n.gitignore顧名思義，這個檔案是用來列出要被 git 忽略的檔案，裡面列出的檔案不會被 git 加入版本控制 讓檔案變成小透明的地方，聰明的你應該有發現 node_modules 也在裡面\npackage.json這個檔案用來記錄專案使用的套件版本資訊、可以下哪些指令等專案的基本資訊，前面有提到可以透過 npm install 重新安裝專案所需的所有套件，至於要下載哪些、和哪個版本的套件就是這個檔案存在的意義了\n調整網站全站設定前面講一堆，終於到動手做的時候啦 ~\n如果你觀察現在的首頁，會發現有一點就是很想給他改掉啦！沒錯，就是那大大 Hexo 單字，那是什麼？跟我部落格完全不搭 ( Hexo 別生氣，沒有針對你的意思 )\n好，說改就改！想修改它就要修改「全站的 config 檔」( 是全站不是主題喔 )，打開檔案後找到 # Site 就可以設定專屬於你的網站資訊囉 ~\n\n內容可以自己慢慢想，我自己光部落格網站的名稱就想了很久，如果想了解更多全站設定的內容可以參考 Hexo 官網文件的配置部分\n設定好儲存開啟伺服器之後，首頁的 Hexo 就改為 Amy 的小天地啦🎉\n\n那你一定會疑惑其他項目改了哪裡？請對網頁按下滑鼠右鍵選「檢視網站原始碼」，看看程式碼前面幾行是不是出現剛剛設定的內容了？\n\n這樣就能客製化你的網站資訊了，記得一定要填 title 和 description，這樣可以幫助你的網站更容易被搜尋到喔 ~\n結語這篇文章介紹了 Hexo 部落格資料夾裡面，到底有哪些神秘資料，這邊主要講解一些比較簡單的介紹，因為不知道大家 git 程度，不知道怎麼寫新手也能理解，有點小困擾但是還是寫完了，最後還講了如何客製化自己的部落格全站網站設定\n大家可以試著開始想自己的部落格名稱囉 ~ 也可以想到再來重溫這篇文章，那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (1) |  Hexo 是什麼？為什麼開始學 Hexo？","url":"/amy10blog/2025/04/21/20250421-hexo-learning1/","content":"開始學 Hexo 的動機進入 Hexo 的簡單介紹之前，先說說我自己開始學 Hexo 的動機，因為我希望能建立一個自己的部落格網站，不只是當作平時學習前端知識的筆記收藏區，也希望透過這些文章分享能幫助到正在學習的新手，而 本人比較懶 Hexo 因為能夠輕鬆完成一個部落格網站的架構，也有許多中文教學幫助初學者入門，建置屬於自己的專屬部落格網站，所以就下定決心要開始學習用 Hexo 完成屬於自己的部落格網站啦 ~\n\n什麼是 Hexo？介紹什麼是 Hexo 之前，先想想如果要寫部落格文章，可能會用哪些方式去撰寫自己的文章？ 1. 使用現有的部落格平台撰寫文章 ，如：痞客邦、iT邦幫忙、Medium… 2. 自己架設部落格網站存放自己的文章接下來就談談這兩種方式的一些優缺比較吧 ~\n使用現有的部落格平台優缺使用現有的部落格平台優點是簡單粗暴不太需要思考， 只要專注在撰寫的文章內容即可 ，因為是使用現有平台所以 平台本身會有一定的流量 ，不太需要過度擔心自己的文章無法被搜尋到等複雜的 SEO 問題\n但這樣的便利伴隨一定的缺點，那就是如果 平台收掉你辛苦寫的文章可能會遺失 ，而且有些平台可能有個人主頁但版型都很一致性可變動部分不多、 無法讓你充分客製化想要的網頁樣式\n架設部落格網站工具比較看完上面使用現有部落格平台的缺點後，如果想避免有些人就會開始考慮架設自己的部落格網站，這時候就會需要一些方便快速的架站工具，如：WordPress、Hexo…，當然可能還有其他架站工具\n但這邊先以我曾經使用過的 WordPress、Hexo 這兩個來說明，這兩個都是架站的工具，一樣都有多種網站主題可以選擇，讓想架設網站的人能夠快速架站，但兩者在架站上還是有差異的\n\nWordPress： 是 動態網頁架站工具 ，動態網頁通常會需要搭配一個資料庫，需要另外 支出動態伺服器的費用 ；客製化網站方面：有提供視覺化的編輯器外掛，不懂程式碼其實也能勉強客製出一個網站\nHexo： 是 靜態網頁架站工具 ，可以想成是部落格網站架設工具，如果 搭配 GitHub 空間可以實現幾乎零成本的網站架設 ；客製化網站方面：需要學習一些程式碼、會用終端機下指令比較容易客製出網站\n\n本人在進入神奇的程式碼世界前有學過一些 WordPress 可以大概說明兩種工具在客製化上面的使用差別， WordPress 雖然有視覺化的編輯器，但如果想進一步客製網站結構跟樣式還是必須要學習一些程式碼的，這也是為什麼我改行學程式碼了🤣\n\n結論看過以上比較，你會發現使用 Hexo 架站雖然能省一些荷包成本，但相對的它就會需要更多的腦力成本，沒錯 ~ 要學習程式碼跟指令才能客製出自己的專屬部落格，不過別擔心之後我會帶大家一起學習 Hexo 的基本指令及其他延伸知識\n\n心情小語其實 Hexo 在去年大概 4、5 月就已經初步學習過了，除了我自己進修上課的學習資源外，還有六角大前輩 Ray 的 Hexo 系列文章，讓我決定在重新翻新架設我的部落格後，來分享自己在架設過程中發現並處理的問題，也會提到一些基本操作，再請大家多多支持 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (5) | Hexo 文章細節調整與如何新增頁面","url":"/amy10blog/2025/04/25/20250425-hexo-learning5/","content":"Hexo 文章細節調整前面有介紹如何新增文章的 Hexo 指令及 Mackdown 語法，其中還有一些細節想和大家說明，Hexo 的文章除了可以 Mackdown 語法編輯文字外，還有一個部份在每個文章檔案的開頭：\n\n沒錯，就是這塊區域，它可以寫入這篇文章的 title、tags 等與文章相關的資訊，接下來就看看這些資訊如何寫入，以及在部落格頁面上會如何呈現囉 ~\ntitle顧名思義就是你文章的主要標題，現在修改後儲存，再開啟 Hexo 伺服器\n\n修改後右側的 Recent Posts 區塊，會呈現你修改後的 title 名稱\n\n進入這篇文章的頁面，你會看到修改後的 title 名稱就是這篇文章最上方的大標題\n\ntags標籤，它是你文章的關聯標籤，假如你的文章內容跟前端技術、Hexo 有關，你就可以在 tags 加上前端和 Hexo 兩個標籤，寫法如下：\n\n儲存後重整網頁，文章的最下方就會出現剛剛修改的 tags 內容\n\n然後你會發現右側出現兩個區塊：Tags 和 Tag Cloud，裡面有剛剛新增的標籤內容\n\n等等！怎麼有兩個跟 tags 有關的區塊？別急，我來解釋，Tag Cloud 這個區塊內的標籤字體會隨相關文章變多而變大\n實際示範，如果我又新增了一篇文章，這次 tags 的內容我輸入： Hexo 和 待辦，這時候跟 Hexo 標籤相關的文章就有兩篇，比 前端 和 待辦 兩個標籤的文章還多，再看看 Tag Cloud ：\n\nTag Cloud 區塊的 Hexo 標籤字體變大了，而反觀 Tags 區塊只有條列新增一個 待辦 標籤：\n\n你以為只有這樣嗎？oh, no no no ！點擊這兩個區塊內任一標籤連結，可以到與該標籤相關的所有文章清單頁面，點擊 Hexo 標籤就會看到有兩篇相關文章：\n\n如何縮短 Hexo 首頁文章長度這個是額外的小補充，也稍微跟文章有關係就放進來講，經過一系列調整你應該有發現首頁左側會顯示你寫的所有文章，很貼心…但是顯示太多了！\n別擔心，你只需要在文章中想截斷的地方，加入 &lt;!--more--&gt; 這行程式碼\n\n噹噹 ~ 神奇的 Read More 按鈕就會出現在首頁左側的區塊的文章卡片中，而且文章卡片內只會顯示 &lt;!--more--&gt; 之前的內文\n\n這樣首頁就簡潔許多囉 ~\n如何新增 Hexo 頁面學到這邊你也許會想我知道怎麼新增文章，但是我想做的不只是寫文章，我想向大家介紹自己或介紹部落格，但是沒有關於頁面可以給我放這些內容怎麼辦？\n別擔心 ~ Hexo 也想到了，你可以用簡單的 Hexo 指令新增頁面，接下來就來看看如何新增並調整 Hexo 網站的頁面吧 ~\n一樣開啟終端機，確認是否在 Hexo 部落格資料夾的路徑上，再執行以下指令\nhexo new page about\n\n執行完之後，你就會看到 source 資料夾中多了一個 about 資料夾\n\n資料夾中有一個 index.md 的檔案，你可以在裡面輸入關於頁面的內容，完成後開啟伺服器你會發現首頁上方沒有地方進去 QAQ ，別急 ~ 這部分之後會說，先在網只後面輸入 /about ，就會看到你新增的 about 頁面囉 ~\n\n如何在網站上方導覽列新增頁面連結確定可以看見你更新的 about 頁面內容後，接下來就來新增導覽列的項目啦 ~ 畢竟現在的項目數量已經滿足不了我們了\n但在新增之前我們要先處理一件事，那就是把現在 Hexo 預設的樣板主題：landscape 安裝好，關於 Hexo 主題的挑選方式在後面會再做介紹\n先進到 landscape 的 GitHub 頁面，往下滑會看到 install 的說明內容，目前 Hexo 5.0 和以後的版本可以用 npm 方式安裝，但這邊先用 git 的安裝方式示範安裝，執行以下 git 指令：\ngit clone --depth 1 https://github.com/hexojs/hexo-theme-landscape themes/landscape\n\n執行後會看到 themes 資料夾多出一個 landscape 的資料夾，然後你會在裡面看見一個 _config.yml 的檔案，這個檔案裡會有關於樣板主題的各種設定\n\n點開那個 config 檔找到 menu ，你會發現它下面的項目很眼熟，沒錯，它就是你要修改的目標，在 menu 下再新增一行 About： /about\n\n修改後儲存再開啟 Hexo 伺服器，你就會看見上方導覽列多出了一個 About，點進去就可以看見你的 about 頁面囉 ~\n\n怎麼把導覽列項目名稱改成中文相信聰明的你，在修改過程中已經發現了，About： /about 中前面的 About 就是導覽列項目的名稱，所以只要將 About： /about 改成 關於： /about ，導覽列 About 項目名稱就會被改成「關於」囉 ~\n當然也可以把所有導覽列項目都改成中文，改法跟 About 一樣，修改完就會像這樣\n\n結語今天的介紹就到這邊，大家可以試著新增頁面，嘗試修改文章細節，希望這篇文章能幫助到在學習 Hexo 的你，那我們下篇文章見 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (3) | 下 Hexo 指令建立部落格環境吧 ~","url":"/amy10blog/2025/04/23/20250423-hexo-learning3/","content":"建立 Hexo 環境的前置經過前篇 激烈的戰鬥 努力的奮鬥，相信大家都安裝好 Hexo 了，那接下來要做的就是建立你的 Hexo 部落格環境啦 ~\n建立專案資料夾首先，在桌面(或其他你想建立專案資料夾的地方)建立一個專案資料夾，我這邊就先在桌面建立一個 amyHexo 的資料夾 (沒錯，我桌面背景是紅色的 ，資料夾的名字可以自己取不用和我一樣\n\n用cd指令移動到指定的路徑再來開啟終端機執行 cd 指令移動到專案資料夾如下，你的資料夾要看你建立在哪個路徑再將你的路徑填入以下 你的專案資料夾路徑 位置裡 (注意：cd 後面有一個空白字元再接路徑)\ncd 你的專案資料夾路徑\n\n以我建立的 amyHexo 的資料夾為例，就要執行 cd c:\\Users\\User\\Desktop\\amyHexo 這個指令，每個人的 User 名字可能不一樣那就看你自己叫什麼囉 ~\n快速填入指定資料夾路徑的方法如果你懶得輸入這麼長的路徑，有一個方法可以試試看，先在終端機輸入 cd 和一個空白字元，再把你想前往的專案資料夾用滑鼠按住左鍵拖曳到終端機視窗內\n\n然後放開滑鼠左鍵， cd 空白後面就會自動填入你拖曳進來的資料夾路徑囉 ~\n\n\n下 Hexo 指令建立環境再來就進入重頭戲用 Hexo 指令來建立你的部落格環境囉 ~\n前面講到 cd 移動到你的專案資料夾中，確定有移動到正確路徑下之後，執行以下指令，其中 你的網站英文名稱 可以自己取名：\nhexo init 你的網站英文名稱\n\n以我的部落格網站英文名稱 amy10blog 為例，下完 hexo init amy10blog 指令後，終端機成功跑完回應就成功囉 ~\n\n執行完以上指令後， Hexo 就會在專案資料夾中建立一個新資料夾，這個新資料夾會用剛剛指令輸入的 你的網站英文名稱 命名，以我的為例新資料夾就會叫 amy10blog：\n\n而新資料夾裡面是所有 Hexo 部落格環境會需要用到的東西，給瞄你一眼：\n\n\n如何瀏覽 Hexo 為你建立的部落格網站呢？說了這麼多，要怎麼看我現在的部落格網站長什麼樣子呢？一樣要用 Hexo 的指令，接著往下看\n使用 Hexo 的指令在本地查看你的部落格網站之前，要記得先移動到 Hexo 剛剛在專案資料夾中幫你建的新資料夾路徑下，以我的為例，就是要移到 amy10blog 資料夾：\n\n接著，再執行以下指令，開啟 Hexo 伺服器\nhexo server\n\n如果嫌棄 hexo server 太長，下 hexo s 這個指令一樣可以開啟 Hexo 伺服器，如果要執行其他指令，想關閉伺服器，可以依照終端機的提示按下 ctrl + c 鍵即可關閉\n\n執行完之後它會回給你一段本地端的網址，點開網址就可以看見目前部落格的樣子囉 ~ 通常初始的部落格網站大家都會長這樣：\n\n後續會再教大家客製化的方法，不過會先把 Hexo 的基本指令講解完再討論這塊，也是有許多研究後的結果可以分享，那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (7) | 部署你的落格網站與常見 Hexo 指令","url":"/amy10blog/2025/04/27/20250427-hexo-learning7/","content":"前置確認是否已安裝 git在開始往下介紹如何用部署你的 Hexo 部落格之前，我們要先確認是否有正確安裝 git，如果你是跟著前幾篇文章實作的朋友，基本上是不用擔心沒有安裝的，因為安裝 Hexo 前，官網的文件就有說明要先安裝 git\n如果你還是想確認可以執行以下指令，有回傳版本號表示你已經安裝好 git 了\ngit --version\n\n還未完成安裝的話可以到參考這系列文章的第二篇，先完成安裝\n\n註冊你的 GitHub確定安裝好 git 之後，先前往 GitHub 官網 註冊你的 GitHub 帳號\n進入官網點擊右上角的 Sign up 按鈕\n接下來就是註冊帳號會有的流程，讓你填寫一些基本資料、回答一些問題 ( 主要是 GitHub 要調查你申請帳號的用途 )，然後請你選擇方案，如果不需要付費才有的功能選擇免費就好\n\n讓 VSCode 綁定你的 GitHub 帳號如果你跟我一樣使用 VSCode，要記得綁定你的 GitHub 帳號往下介紹前先做個小補充：讓 VSCode 介面中文化套件\n可以在 VSCode 左邊找到以下圖示，然後在側欄搜尋框搜尋 chinese，找到中文化套件點擊它之後右邊會出現這個套件的相關介紹，點擊「安裝」按鈕，然後關掉 VSCode 在重開就可以看見中文化的 VSCode 介面囉 ~\n\n安裝完套件之後相信大家就能看見中文化的介面了，接下來往下介紹如何讓 VSCode 綁定 GitHub 帳號\n打開 VSCode 點擊左下的人像 icon，再選擇「啟用雲端變更…」( 英文介面應該叫：Turn on Cloud Changes… )\n\n然後最上方搜尋框會跳出兩個項目，選擇「利用 GitHub 登入」\n\n再來就會跳出一個 GitHub 的視窗，要你確認綁定的帳號，確定好後點擊「Continue」\n\n然後就會出現請你授權給 VSCode 的視窗，點擊「Authorize Visual-Studio-Code」\n\n最後會出現確認視窗，點擊「開啟 Visual Studio Code」\n\n打開 VSCode 點擊左下的人像 icon，就可以看見圖中白色長方處會出現你的 GitHub 帳號，如果中間遇到錯誤可以關閉 VSCode 再重啟\n\n如果以上步驟都順利完成就恭喜你完成綁定囉🎉\n新增 GitHub 空間完成前置的一番奮鬥，接下來就可以用你的 GitHub 帳號新增 GitHub 空間，也就是 GitHub 儲存庫 ( GitHub repository，以下簡稱 GitHub repo )，把你的 Hexo 部落格推上去囉 ~\n登入你的 GitHub 帳號後會出現你的 Dashboard，點擊右上方你的頭像會跳出以下選單，選擇「Your repositories」\n\n進入 Your repositories，這裡會有所有你創建的 GitHub repo，點擊右上方的「New」按鈕\n\n然後就可以在 Repository name 填入你的 GitHub repo 名稱\n\n完成後就點擊下方的「Create repository」按鈕，就可以進入你剛剛建立的 GitHub repo 頁面了，左上 GitHub Logo 旁邊的白色長方處會顯示你的 GitHub 帳號，在往右就是你剛剛命名的 GitHub repo 名稱\n\n學會如何新增 GitHub repo 之後，我們就繼續往下前進\n部署你的部落格到 GitHub Page首先，先到 Hexo 的官方文件，上面有寫到關於「在 GitHub Pages 上部署 Hexo」的內容，讓我們看到「一鍵部署」( One-command deployment )這一節的內容\n接下來就一步步完成部署吧 ~ 首先進入 hexo-deployer-git，往下滑查看 README 的說明，可以看到 Installation 提供了以下安裝指令\nnpm install hexo-deployer-git --save\n\n複製安裝指令貼到終端機 ( 記得確認是否在 Hexo 部落格資料夾的路徑上 )，然後執行\n\n安裝好之後，要在「全站的 config 檔」中加入以下內容\ndeploy:  type: git  repo: https://github.com/&lt;username&gt;/&lt;project&gt;  # example, https://github.com/hexojs/hexojs.github.io  branch: gh-pages\n\n點開全站的 config 檔後，找到 deploy 的區塊替換成以上內容，這時候眼尖的你一定會發現 repo 這一項似乎有些內容要修改\n沒錯，網址中的 &lt;username&gt; 要改成你的 GitHub 帳號，&lt;project&gt; 則要改成你的 GitHub repo 名稱，假設我的帳號是「amy12345」、repo 名稱是「amy_hexo」，那 repo 這項就要改成：https://github.com/amy12345/amy_hexo\n其中 branch 這項，代表之後部署 Hexo 部落格到 GitHub Pages 時，會部署到哪個分支名稱，這邊可以直接用預設名稱 gh-pages\n\n接下來是不是要下指令部署啦？\n先等等！全站的 config 檔還有東西要改，我們找到 url 然後會看見檔案中的註解有提示，如果你是用 GitHub Pages 要把 url 這項改成：https://username.github.io/project，經過前一個步驟，聰明的你一定已經知道要怎麼改了吧 ~\n用我前面的範例套用，我的 url 這項就要改成：https://amy12345.github.io/amy_hexo\n\n好的，接下來就是期待已久的下指令啦 ~ 執行以下指令部署你的 Hexo 網站到 GitHub Pages ( 如果之後要更新網站內容一樣要用以下指令部署 )\nhexo clean &amp;&amp; hexo deploy\n\n\n\n補充：hexo clean 跟 hexo deploy 是兩個不同指令，hexo clean 會清除原先有的 public 資料夾，確保後續部署的是最新的網站內容，而 hexo deploy 執行後會產生 public 資料夾，裡面是編譯後的網站內容，且還會把編譯內容部署到 GitHub Pages\n\n\n執行完成後回到你的 GitHub repo 頁面，重新整理就會看見出現了剛剛部署的 gh-pages 分支\n\n然後點擊上方的「Settings」\n\n選擇左側欄的「Pages」，就會在黃框處看見你部署到 GitHub Pages 的部落格網址，如果沒出現網址就稍等一下再重整網頁\n\n點進網址後，就可以看見你的部落格囉 ~\n\n\n小提醒：點進網址後如果還沒出現預期的網站樣式，就等一下再重整網頁或用無痕模式開看看，等很久還是沒反應，就需要檢查前面提到的全站 config 檔設定，是否有錯誤或缺漏，有的話修改儲存後再重新下指令部署\n\n常見 Hexo 指令看到這篇文章恭喜你👏已經將 Hexo 指令學得差不多了，接下來就列出一些比較常見的 Hexo 指令做個小統整吧 ~\n\nhexo init 你的網站英文名稱：初始化 Hexo 部落格環境的指令，init 後面接自訂的網站英文名稱，執行後會在專案資料夾中，新增 Hexo 部落格網站的資料夾，該資料夾名稱與自訂的網站英文名稱相同\nhexo server 或 hexo s：開啟 Hexo 伺服器，執行後可以在本地端查看 Hexo 網站的樣子\nhexo new &#39;你的文章名稱&#39;：新增 Hexo 部落格文章，new 後面接自訂的文章名稱，記得名稱要用單引號包住，執行後會在 source 內的 _posts 資料夾中新增一個文章的 md 檔\nhexo new page 頁面英文名稱：新增 Hexo 網站的頁面，page 後面接頁面英文名稱，執行後會在 source 內新增該頁面名稱的資料夾，裡面有 index.md 檔，頁面相關設定可見本系列文章第五篇\nhexo clean：執行後會清除 public 資料夾\nhexo deploy：執行後會產生 public 資料夾，並把裡面編譯後的網站內容部署到 GitHub Pages\nhexo generate 或 hexo g：執行後會產生 public 資料夾，裡面是編譯後的網站內容，和 hexo deploy 不同，不會把網站內容部署到 GitHub Pages\n\n結語看完這篇文章相信大家都能夠了解，如何將自己的 Hexo 部落格網站部署到 GitHub Pages 了，其實說到 GitHub 通常會講到 git 指令，但是這個系列主要還是介紹 Hexo，怕模糊焦點所以就先不談 git 的相關知識 (留給未來的我寫\n作為補償我幫大家整理了 Hexo 的常見指令，請笑納🫡，不過如果想多了解 git 的內容可以參考以下的一些學習資源：\n\nGit &amp; GitHub 教學手冊\n為你自己學 Git\n\n那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (8) | landscape 主題如何客製 Hexo 首頁","url":"/amy10blog/2025/04/28/20250428-hexo-learning8/","content":"激發你的客製魂經過前面的努力我們終於把 Hexo 網站部署到 GitHub Pages 了，但是這樣用主題模板套用的固定結構、樣式的網站，滿意嗎？\n沒錯！我們不滿意！這篇文章就是來激發你的客製魂的，接下來就開始介紹如何用預設主題 landscape 來客製化你的 Hexo 網站吧 ~\nEJS 樣版語言開始客製化之前需要先認識一下 EJS 這個樣版語言，這邊會簡單先講解它的作用，如果想深入了解語法可以到 EJS 官網文件查看官方說明\n仔細觀察你應該會發現你寫的每篇文章頁面，網頁的結構跟樣式都很相似，唯一不同的是文章內容\n前面提過只要在 source/_posts 資料夾的 md 檔內寫入文章內容，文章內容就會更新到該文章的頁面上，不需要每篇文章都新增一個不同的 HTML 檔…\n而 landscape 主題就是使用 EJS，做到把網站中重複部分拆分成不同 EJS 檔，再將每個部分的結構和不同資料內容，整合到一個 layout.ejs 的檔案中\n簡單來說 EJS 樣版語言，可以做到把網頁結構跟資料組合成一個個看起來結構很像，但顯示資料卻不同的網頁 ( 像每篇文章頁面一樣 )\n比較以下 Hexo 的文章頁面，網頁的結構、樣式都一樣，只有文章內容不同\n\n\nlayout.ejs 檔案前有提到網站的結構跟資料會整合到一個 layout.ejs 的檔案中，那接下來就看看這個檔案，試著調整看看會對網頁產生什麼改變吧 ~\n首先點開 themes 底下的 landscape 資料夾，在點開裡面的 layout 資料夾，就會看見 layout.ejs 的檔案，點開它你會發現檔案的內容很像 HTML，但是又混合一些用 &lt;%- %&gt; 包住的程式碼\n&lt;%- %&gt; 內可以寫入 JavaScript 控制網站結構，也可以匯入其他檔案的內容到 layout.ejs 檔中，匯入的結構或資料會放在 &lt;%- %&gt; 程式碼所在的位置\n\n先看 &lt;%- partial(&#39;_partial/head&#39;) %&gt; 這個片段，在這行程式碼的位置引入了網站的 head，被引入的是在 _partial 資料夾內的 head.ejs 中的內容\n點開檔案可以看到確實有 &lt;head&gt; 標籤和 head 裡面會有的內容\n\n\n不確定引入的是不是這個檔案怎麼辦？雖然現在知道怎麼找被引入檔案的位置，但如果不確定到底引入的是不是這個檔案，要怎麼辦？\n這時候可以試著修改那個檔案的內容，觀察網站結構是否改變，現在模擬一下情境：\n假設我想加入文字到網站的 footer 位置，這時候我開啟 Hexo 伺服器，點開本地端的網站連結，打開 Chrome 的開發者工具，查看 Elements 的 HTML 結構，發現 footer 的區塊被包在 &lt;div id=&quot;wrap&quot;&gt; 的最後面\n\n這時候我回到 layout.ejs 檔，尋找 footer 區塊的對應位置，發現它可能在第 14 行\n\n第 14 行程式碼有看到 partial(&#39;_partial/footer&#39; 這樣的內容，所以我覺得被引入的是 _partial 資料夾內的 footer.ejs 檔，但我不太確定，就先在這個檔案內嘗試加入一行字\n\n加入文字後儲存再重新整理網站，footer 確實有加入我剛剛輸入的文字內容，所以被引入的檔案就是 footer.ejs \n\n經過上面示範的模擬情境，應該就比較知道要如何找到你要客製化的部分在哪，以及不確定時要怎麼驗證了，來嘗試找找想客製的部分在哪個檔案中吧 ~\n怎麼客製化滿版頁面如果去看 Hexo 網站的每個頁面，你會發現右側都有一個側欄選單，如果想讓關於或是首頁變成沒有側欄選單的滿版頁面，要怎麼做呢？\n還記得前面有提到，如何用文章 md 檔的開頭調整文章細節嗎？接下來就可以運用這個方法，讓你可以控制頁面是否要滿版顯示\n假設我希望關於頁面可以滿版顯示，先打開 source/about 下的 index.md 檔，在開頭加入自訂的內容：fullPage: true\n\n看到小駝峰的命名方式應該可以預感到，沒錯… 接下來就是 JavaScript 登場的時候的，接下來會寫入一些 JavaScript 的內容到 layout.ejs 中\n但首先，要先找到我們想去除的側欄選單在檔案中的哪個位置，這時候就是依照前面的步驟，先在 Chrome 的開發者工具的 Elements 內，找到側欄選單的 HTML 結構位置\n你會發現它在 &lt;div class=&quot;outer&quot;&gt; 內\n\n然後就是找到 layout.ejs 檔案中對應的位置：第 10 ~ 12 行\n\n再來就是在第 10 行 if ( 後面寫入 JavaScript 判斷，修改後程式碼如下，這樣當 fullPage 是 ture 就不會顯示側欄選單\n&lt;% if (!page.fullPage &amp;&amp; theme.sidebar &amp;&amp; theme.sidebar !== &#x27;bottom&#x27;)&#123; %&gt;\n\n加入後儲存再查看關於頁面右邊的側欄消失了\n\n\n滿版 CSS 樣式調整接下來你會發現側欄是消失了，但是左邊區塊怎麼沒有滿版向右邊延伸？\n那就要靠 CSS 的力量來調整了，但是如果直接改控制排版的 CSS 屬性，可能會連其他頁面版面都一起被調整，所以這時候就需要透過新增一個 class，來增加 CSS 權重用覆蓋方式，蓋掉原本 landscape 預設的樣式\n先用開發者工具找到是誰在控制頁面排版，這邊可以看到控制頁面排版的 CSS 屬性設定是 float: left;，選擇器是用 #main\n\n接下來回到 layout.ejs 檔案，找到 container 然後加入 class 屬性，class 屬性值寫入 JS 判斷讓 fullPage 為 true 時，再加入 fullPage 這個值\n&lt;div id=&quot;container&quot; &lt;%- page.fullPage ? &#x27;class=&quot;fullPage&quot;&#x27; : &#x27;&#x27; %&gt;&gt;\n\n回到網站查看會發現只有關於頁面，可以看見 container 多了 fullPage 這個 class，其他頁面則沒有\n\n再來就是調整 CSS 啦 ~ 因為還沒講到 CSS 檔案怎麼客製化調整，所以這邊先在 layout.ejs 的 &lt;/body&gt; 結尾標籤前，用 &lt;style&gt; 標籤直接寫入 CSS 樣式\n這邊選擇器 .fullPage #main 權重較大，可以覆蓋原本的 CSS 預設樣式，除了把 float 改為 none 之外，也順便把 width 改成 100% 滿版樣式滿起來\n\n回去查看關於頁面，就可以看見滿版頁面樣式囉 ~\n\n客製你的 Hexo 網站首頁知道如何客製滿版頁面之後，接下來可能就會想動動網站的門面「首頁」，對 ~ 接下來就來看看怎麼讓首頁不要顯示成部落格文章列表，改成自己客製化的網頁結構囉 ~\n假如我想客製化首頁，但是又想保留現在首頁的結構樣式，把它移到落落格的頁面，要怎麼做呢？\n首先，先修改目前首頁的路由網址，進到全站的 config 檔，找到 index_generator 片段，把 path 這項改成 &#39;/blog&#39;\n\n再來就是設定導覽列的網址，和前面文章提過的修改方式差不多，一樣到主題的 config 檔的 menu 設定，這邊把網址路由 /archives 改成 /blog\n\n然後執行 hexo clean 指令清除目前的編譯檔後，重新開啟 Hexo 伺服器，點擊上方導覽列的部落格項目，進入後就會看到原本的首頁出現了\n\n接下來就是放首頁 HTML 檔的時候啦 ~ 到 source 資料夾內新增一個 index.html 檔案，在檔案開頭加入 title 和 fullPage 的設定，然後加入首頁的 HTML 結構\n\n回到網站進入首頁，剛剛寫的文字就出現在首頁囉 ~\n\nCSS 樣式怎麼客製調整修改好首頁之後，你可能會想要再多客製一些網站的樣式，那就需要修改主題的 CSS 樣式了\n進到 themes/landscape/source 路徑下，會看見一個 css 資料夾，裡面有一個 style.styl 檔，打開會看到內容很像 Sass 的寫法，styl 檔其實是一個叫 Stylus 的 CSS 預處理器，作用跟 Sass 很類似\n如果有學過 Sass，可以試著自己修改裡面的樣式，在客製化時如果擔心直接修改，之後需要更新版本會有影響，可以註解原本的預設設定的內容，方便日後對照修改前後的內容\n另外也可以使用 CSS 的方式客製樣式，前篇常見的 Hexo 指令有提到執行 hexo generate 指令，會產生 public 資料夾，裡面是編譯後的網站內容\n沒錯，接下來就是執行 hexo generate 指令，然後進去 public 找到 css 資料夾 ，你會看見有一個 style.css 檔案\n\n這個檔案裡是目前網站套用的 CSS 樣式，把它複製到剛剛 themes/landscape/source 路徑下的 css 資料夾內\n\n然後打開 style.styl 檔，在最底下加入 @import &quot;style.css&quot; 這行程式碼，引入剛剛複製的 style.css 檔覆蓋原本的樣式\n\n接下來就可以在剛剛複製的這個檔案中，客製化自己的網站樣式啦 ~\n修改導覽列項目文字顏色假設我想修改網站上方導覽列項目的文字顏色，要怎麼做呢？\n首先，一樣利用開發者工具，查看控制導覽列項目文字顏色的 CSS 屬性在哪，這邊可以發現是 .nav-icon, .main-nav-link 這個選擇器內的 color 屬性在控制\n\n看上圖黃框處，可以知道這行程式碼在 style.css 檔內大約 381 行的位置，接下來就來修改 color 屬性，我要改成 pink 粉粉der\n\n再來先執行 hexo clean 清除舊的編譯內容，然後再開啟 Hexo 伺服器，就可以看見上方導覽列文字 pink 起來啦 ~\n\n接下來就可以利用以上方法，自由的在 style.css 檔中客製化自己的網站樣式囉 ~\n結語這篇文章介紹了如何在 landscape 主題中，客製化 Hexo 的網站樣式，這些客製方法是學習加上實作後得來的，也鼓勵大家實作遇到問題，可以多查看官方文件，或是尋找大神寫過的技術文章，來解決目前遇到的難題\n不同 Hexo 主題在客製化上可能要修改的地方會不同，但如果可以跟上這篇的操作，就可以期許自己去研究如何客製化你更喜歡的 Hexo 主題，不用侷限在 landscape 主題\n下篇文章會帶大家學了解如何挑選及更換主題，那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (9) | Hexo 主題選擇及更換網站主題","url":"/amy10blog/2025/04/29/20250429-hexo-learning9/","content":"關於 Hexo 主題挑選Hexo 的主題不只有 landscape 這一種，還有許許多多的主題模板可以套用，進入 Hexo 官網的主題頁面，你就能看見很多主題\n\n點擊任一個主題標題名稱 ( 如上圖紅框處 )，可以進入該主題的 GitHub 頁面，裡面會有主題的安裝方式、使用說明等資訊\n如果想看套用該主題的範例網站，就點擊「Visit preview site」( 如上圖綠框處 )\n有很多主題可以選當然好，但是選擇障礙就出來了，挑選主題有沒有什麼需要注意的事項呢？\n當然有，接下來就來針對挑選主題要注意的點來說明吧 ~\n有實力有經驗也不懶怎麼選都行如果你有一定開發實力，且有開發過主題的經驗，然後也不懶熱衷於挑戰 (？，那麼你想挑什麼主題都可以，反正有問題可以自己改👍\n但如果你跟我一樣比較懶，可以根據以下提到的兩點挑選主題，可以少一些研究主題的時間，更專注在部落格經營及技術文章撰寫上\n\n挑選有持續維護的主題\n挑選熱門的主題\n\n挑選有持續維護的主題前面有說可以透過 Hexo 官網的主題頁面，進入到該主題的 GitHub 頁面，在這邊可以看見主題的一些相關資訊\n以 NexT 這個主題為例，下圖紅框處可以看見更新專案的時間，這邊可以看到上個月甚至昨天都有更新\n\n這個更新的時間，可以作為這個主題是否有持續維護的判斷標準，如果更新時間是好幾年前，那表示這個主題已經很久沒有更新維護了\n這樣對於使用較新版本 Hexo 的使用者來說，可能不是一個好選項，因為沒有持續維護的主題，可能會與現在使用的 Hexo 版本不相容，主題無法被新版本的 Hexo 編譯，就只能放棄這個主題了\n除非有足夠實力自己修正問題，不然建議選擇有持續維護的主題套用，避免以上的狀況發生\n挑選熱門的主題另一個挑選主題的重點是挑選熱門的主題，那要如何判斷我選的主題熱不熱門呢？\n一個主題熱不熱門，除了搜尋主題名稱，查看網路上相關技術文章的數量之外，也可以透過該主題的 GitHub 頁面找到一些蛛絲馬跡\n頁面右上的這個星星數量就可以作為判斷，星星數量越多越熱門\n\n另外 Issues 的數量也可以當作判斷標準，熱門的主題因為比較多人使用，就容易有較多人在使用上遇到問題，然後到 GitHub 頁面尋求協助，所以主題的 Issues 數量越多越熱門\n像是 NexT 主題 GitHub 的 Issues 分頁，下圖黃框處已解決 ( Closed ) 的 Issue 就算蠻多的了\n\n會建議挑選熱門的主題，是因為社群針對熱門主題的討論度較高，這樣未來若遇到實作上的問題，可以參考學習的資源也較多\n更換 Hexo 網站主題接下來會以 NexT 來示範，如何更換 Hexo 網站的主題\n我們知道原本 Hexo 網站的主題，預設是套用 landscape，假設現在我們想把網站主題換成 NexT 主題，要怎麼做呢？\n\n注意：如果前面有針對 landscape 主題客製化，為避免調整影響到 NexT 主題的套用，建議重新建立一個新的 Hexo 部落格環境或移除客製化設定，再依照以下步驟更換主題\n\n首先，先進入到 NexT 主題的 GitHub 頁面，滑到頁面下方會看到 README 裡有安裝方法\nInstallation 列出兩種安裝方式，一種是透過 npm 但 Hexo 版本要 5.0 或以上，另一種是用 git clone 的方式\n\n這邊示範採用 git clone 的方式安裝主題，開啟終端機注意是否在 Hexo 部落格資料夾的路徑上，是的話執行以下指令\ngit clone https://github.com/next-theme/hexo-theme-next themes/next\n\n執行後打開 themes 資料夾，可以看到多了一個 next 的主題資料夾\n\n接下來打開全站的 config 檔，找到 theme 把 landscape 改成 next\n\n修改後儲存再打開 Hexo 伺服器，點開網址就可以看見網站被改成 NexT 主題的樣式囉 ~\n\n如果要更換成其他主題，也是差不多的方式，參考該主題的安裝方式先進行主題安裝，再調整全站 config 的 theme 設定\n結語這篇文章介紹了如何挑選你的 Hexo 網站主題，以及如何安裝並更換主題，看完這篇文章大家可以試著挑選喜歡且合適的主題囉 ~\n希望大家都可以有美美的 Hexo 網站，每個主題客製化上面設定可能會不一樣，但前篇文章提到的客製化方法，應該多少還是可以作為實作時的參考\n接下來文章因為我個人創建自己的部落格，研究比較多的是 NexT 主題，所以會以如何客製化 NexT 主題為主要方向\n那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"從零開始學 Hexo (10) | NexT 主題篇 - 客製化主題樣式","url":"/amy10blog/2025/04/30/20250430-hexo-learning10/","content":"NexT 主題官方文件在客製化過程中，我蠻常參考 NexT 主題官網的，然後會有一些想調整的地方，其實 NexT 主題的 config 檔都有地方可以設定\n所以在往更深的程式碼調整客製介紹之前，我想先針對 NexT 主題的 config 檔中，可以調整的內容做一些簡單介紹\nNexT 主題的 config 檔接下來會介紹一些在 NexT 主題的 config 檔中，可以用來調整網站樣式的設定，為了避免重複說到檔案名字，先說明一下，以下提到的設定都是在 NexT 主題的 config 檔中修改的內容\n開啟選單項目NexT 主題的選單是需要自己設定開啟的，這邊的選單就很像是網站上方的導覽列，要調整選單要顯示什麼內容，就需要調整以下的 Menu Settings 區塊了\n\nmenu首先，上方的 menu 可以控制選單要開啟哪些項目，以及調整項目對應的路由跟 icon\n要開啟哪個項目，就刪除該項目開頭的井字號 # 解除註解，反之就加上井字號 # 註解掉，假設我想開啟前五個項目，就把前五項解除註解就可以了\nmenu:  home: / || fa fa-home  about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags  categories: /categories/ || fa fa-th  archives: /archives/ || fa fa-archive  #schedule: /schedule/ || fa fa-calendar  #sitemap: /sitemap.xml || fa fa-sitemap  #commonweal: /404/ || fa fa-heartbeat\n\n設定好儲存，再開啟伺服器，就可以看到網站多出了剛剛開啟的選單項目囉 ~\n\n再來假設我想把選單首頁的 icon 改成愛心，要如何調整設定呢？\n這邊的 icon 是使用 Font Awesome 這個網站的 icon，所以我們就進到這個網站搜尋 heart，找到我想要的愛心 icon 點擊它\n然後就會跳出這個 icon 的套用資訊，把圖中紅框處的代碼複製下來\n\n貼到首頁那項 || 後方，取代原本的 icon 代碼\nhome: / || fa-solid fa-heart\n\n小補充：fa-solid fa-heart 前面的 fa-solid 可以簡寫成 fa，所以也可以改成以下這樣\nhome: / || fa fa-heart\n\n重整網站就可以看到首頁的 icon 改成愛心囉 ~\n\n\n注意 ：記得執行 Hexo 指令新增頁面，才能連結到該頁面喔 ~ 如：要連結到標籤頁面，要先執行 hexo new page tags 新增頁面，點擊選單的標籤才能看到標籤頁面 ( archives 不用新增頁面，預設已經有連結的頁面了 )\n\n補充 ：在 NexT 主題的標籤跟分類頁面開頭，分別加入 type: tags 和 type: categories 可以開啟該頁面預設的內容 ( 如下圖 )\n\n\n\n\nmenu_settings再來介紹 menu_settings 下的設定，icons 可以調整選單項目 icon 的開關，badges 可以調整選單項目數量標記的開關\n接下來調整 icons 改成 false，badges 改成 true，實際看看選單項目會有什麼變化\nmenu_settings:  icons: false  badges: true\n\n設定好再重整網站，會發現選單項目的 icon 都不見了，但是標籤、分類、歸檔這三項多出了數量標記，代表這三項總共有多少數量\n\n這邊歸檔的數量是指網站的文章總共有幾篇，標籤跟分類對應的是文章 md 檔開頭的 tags 跟 categories ( 忘記請參考下方補充 )，所以標籤跟分類後面的數量，分別代表的是網站中所有文章不重複的 tags 有幾個、categories 有幾個\n補充：文章開頭設定 categories 跟 description\ncategories\n\n文章 md 檔開頭的 tags 跟 categories 可以這樣設定，因為 landscape 主題沒用到，所以之前沒有示範過 categories 的設定，這邊補上\n\n有文章有設定 categories 之後，再回去看網站就會看見分類項目的數量變成 1 了\n\n\ndescription\n\n前面有說到如何讓首頁的文章只顯示部分內文，只要在文章中想截斷的地方加入 &lt;!--more--&gt;，首頁就會只顯示部份內文，然後多出一個 read more 按鈕，讓瀏覽者點擊查看全文\n在 NexT 主題還有提供另一個產生 read more 按鈕的方法，跟 &lt;!--more--&gt; 不同的地方是，這個方法可以讓你自訂要顯示的內容是什麼，那就是在文章開頭設定 description\n首先在一篇文章的 md 檔開頭加入 description，然後寫入想在首頁文章卡片顯示的文字內容\n\n完成後重整網站，查看首頁就會看見文章卡片顯示的是，剛剛 description 設定的內容\n\n\n調整不同模板樣式NexT 主題本身有提供 4 種不同模板樣式，示範網站如下：\n\nMuse\nMist\nPisces\nGemini\n\n這邊示範網站提供的是暗色的主題樣式，在還沒調整設定之前預設會是亮色的主題樣式，兩者主要只是以黑或白為主色的差別而已在調整色系前，先來看看如何調整不同模板樣式吧 ~ 順便給大家看看 4 種不同亮色的主題長什麼樣\n調整模板樣式的方式很簡單，找到 scheme 改成你想要的模板樣式名稱就可以囉 ~\n假設我要改成 Gemini 這個樣式，只要把原本的樣式註解掉，再解除想要樣式的註解，就會套用這個樣式的主題了\n\n亮色的 4 種不同模板樣式網站畫面：\n\nMuse\n\n\n\nMist\n\n\n\nPisces\n\n\n\nGemini\n\n\n\n調整明暗主題色系除此之外，NexT 主題還可以選擇明暗色系的主題樣式，這對於喜歡暗色系網站的我來說就是福音，白色對我來說太明亮了 太耀眼了，看太久會被消滅\n調整方式也很簡單，只要在 NexT 主題的 config 檔中，把 darkmode 改成 true，就可以開啟 暗黑模式 暗色系的主題樣式囉 ~\n\n然後重整網站，搭啦 ~ 網站就變成暗色系的主題樣式了🪄\n\n\nfavicon、logo、作者頭像設定如果你自己有設計網站的 logo，或是自己的頭像，NexT 主題也可以幫你把這些圖片客製到你的網站上\n先說 logo 的部分，找到以下片段，這邊可以調整網站的 favicon 和 logo，這兩個部分的相關設定\n\nfaviconfavicon 就是網站頁籤紅框處的這個圖片，通常會放 logo，這部分就要用 favicon\n\n上面提到的網站頁籤圖片就要靠 favicon 下的設定來調整，你會看見 small 跟 medium … 各個項目，每個設定都有一串圖片路徑，它們來自一個 images 的資料夾\nfavicon:  small: /images/favicon-16x16-next.png  medium: /images/favicon-32x32-next.png  apple_touch_icon: /images/apple-touch-icon-next.png  safari_pinned_tab: /images/logo.svg  #android_manifest: /manifest.json\n\nimages 資料夾在 themes/next/source 路徑下，打開來你就會看到主題預設給你的 logo 跟頭像圖片\n\n接下來就是依照預設圖片的尺寸，去設計 favicon 的圖檔，然後把 favicon 下的圖片路徑改成新的圖片路徑即可，假如 small 要改成套用 images 資料夾中 favicon-small.png 這個檔案的話，路徑就要改成以下這樣\nsmall: /images/favicon-small.png\n\n我自己是把 favicon 下的沒註解掉的項目，都改成自己的 logo 了，但你可以看自己的需求做調整就好\nlogo接下來調整網站的 logo 圖片，找到以下片段，備註有說 Mist 樣式不支援客製化 logo 的設定，所以選擇 Mist 樣式的朋友，如果有這項需求可以考慮換成其他樣式\n\n跟上面的 favicon 一樣，可以把設計的 logo 圖檔放到 images 資料夾中，然後再調整圖片路徑，假設我要改成 images 中 logo.png 這個圖檔，那路徑就要改成以下這樣\ncustom_logo: /images/logo.png\n\n設定好之後回到網站重整，就可以看見網站上多出了 logo 的圖片\n\n不同樣式 logo 位置可能會不同，這邊就不一一示範，留給大家去嘗試囉 ~\n作者頭像如果你有自己想放的頭像，NexT 主題也有提供一個地方讓你放頭像的圖片路徑\n找到以下的 avatar 片段，然後跟前面設定方式一樣，在 images 資料夾放入你想放的頭像圖檔，然後修改 url 的圖片路徑設定\n\n假設要放的圖檔名稱是 myphoto.png，url 這項的路徑就要改成以下這樣\nurl: /images/myphoto.png\n\n設定後回到首頁就可以看見側欄出現了剛剛設定的頭像\n\n再來這個片段還有 2 個設定：rounded 跟 rotated\n把 rounded 設定為 true 可以將頭像裁切成圓形，呈現畫面如下\n\n而 rotated 設定為 true 可以讓頭像新增一個 hover 的動畫效果，當瀏覽者把滑鼠移到頭像上時，頭像會像唱片一樣旋轉，這個效果就留給大家嘗試看看喜不喜歡囉 ~\n\n社群連結按鈕既然說到了作者頭像如何設定，那就接著講如何設定你的社群連結按鈕吧 ~\n找到以下片段，social 下預設註解就有一些常用的社群連結及 icon 圖案設定，也可以另外新增其他的社群媒體連結及 icon 圖案\n\n這邊的 icon 修改方式跟 menu 選單項目設定的方式一樣，找到想要的 icon 代碼加入即可\n假設我想新增 Discord 的社群按鈕，我找到 Font Awesome 中 icon 代碼是 fa-brands fa-discord，那就可以新增 Discord 設定到 social 下，這邊 icon 代碼 fa-brands 可以簡寫成 fab\nsocial:  Discord: https://discord.com/你的Discord || fab fa-discord\n\n設定後重整網站，就可以看見首頁側欄最下面出現剛剛設定的 Discord 社群按鈕囉 ~\n\n再往下可以看見還有 social_icons，這個片段可以調整社群按鈕的 icon 設定\nsocial_icons:  enable: true  icons_only: false  transition: false\n\n每項設定介紹如下：\n\nenable：可以設定社群按鈕是否要顯示 icon\nicons_only：可以設定社群按鈕是否要只顯示 icon、不顯示文字\ntransition：可以設定是否顯示 icon 的 transition 效果\n\ntransition 效果我自己其實看不太出差異，但官方文件說有這個效果，說不定有人感覺有差，那這個片段就留給大家嘗試自己喜歡的設定囉 ~\n\ncopy right再來我相信一定會有人想改 copy right 預設的內容吧？我自己是很想改成其他可愛的 icon，這樣每次看到都會療癒一下，接下來就來介紹以下 copy right 預設內容如何調整吧 ~\n\n先找到以下片段\n\nfooter 下會有 icon、copyright、powered 三個設定，這三個設定可以用來調整網站 footer 區塊的 copy right 內容\n\nicon：有 name、animated、color 這三項，可以設定下圖黃框處的 icon\nname：用來設定 Font Awesome 的 icon 圖案代碼\nanimated：用來設定是否開啟讓 icon 跳動的動畫\ncolor：用來設定 icon 的顏色\n\n\ncopyright：可以寫入在下圖紅框處要顯示的文字，未設定會預設為全站 config 檔設定的 author 名稱，設定為 false 可不顯示整段 copy right 文字 ( 不包含強力驅動文字 )\npowered：可以設定是否要顯示下圖綠框處的強力驅動文字\n\n\ncopy right 的文字通常會寫類似：「轉載文章時請附上作者名及原文連結」的內容，然後我自己是會關閉強力驅動的文字，改一個喜歡的 icon 圖案、換顏色再加動畫 會跳動的 icon 比較可愛\n示範一下設定內容\nicon:  name: fa fa-user-astronaut  animated: true  color: &quot;#0080FF&quot;copyright: 轉載文章時請附上作者名及原文連結powered: false\n\n設定後重整網站，footer 就會變更成新設定的內容囉 ~\n\n這邊大家可以實際操作設定自己的 copy right 內容，看看自己比較喜歡哪種設定\n如何調整文章開頭的顯示文字再來我想應該會有人，想調整下圖紅框處文章開頭的這串文字吧？如果用預設再加上有分類項目的話，感覺確實資訊很多很雜\n\n首先先找到以下片段\n\npost_meta 這個片段可以用來調整文章開頭的區塊要顯示哪些內容\n\nitem_text：用來設定是否要顯示項目前方的「發表於」、「更新於」、「分類於」文字 ( 如下圖黃框處 )\n\n\n\ncreated_at：用來設定是否要顯示文章的發表日期 ( 如下圖綠框處 )\n\n\n\nupdate_at：用來設定文章更新時間 ( 如下圖藍框處 ) 的顯示方式\nenable：用來設定是否要顯示文章的更新日期\nanother_day：用來設定當發表日期和更新日期相同時，是否要顯示文章的更新時間，true 會不顯示更新時間、false 則會顯示更新時間\n\n\n\n\n\ncategories：用來設定是否要顯示文章的分類項目 ( 如下圖橘框處 )\n\n\n這邊就讓大家試試看要顯示哪些內容在文章標題下方囉 ~\n\n客製化檔案路徑如果你有自己寫的程式碼想要加入網站中的某些區塊，NexT 主題有提供一個區塊 custom_file_path，讓使用者可以設定客製的檔案路徑\ncustom_file_path 區域上方的註解有說明，可以新增客製化檔案到 source/_data 路徑下，也可以用以下預設內容來新增不同網站部分的客製化檔案\n\n這部分如果有需要可以多多運用，裡面還可以自己設定網站的樣式變數、也可以新增自己的 styles.styl 檔讓網站套用你寫的樣式檔，另外還可以針對網站結構也做客製，這邊看到可以新增不同部分的 njk 檔\n\n更多檔案中的設定其實 NexT 主題 config 檔中的設定還蠻多的，這裡介紹的只是一部份我想分享的設定，也推薦大家客製化遇到問題可以先探索一下這個檔案，如果有遇到想了解的設定也可以參考官方文件，多多探索可以幫助你更快掌握如何客製化\n客製化修改程式碼雖然有一些網站部分內容的客製化，可以透過上面提到的 NexT 主題 config 檔來設定達成，但是可能會有些東西你很想客製化，卻無法透過以上方法來調整設定\n這時候就需要直接修改主題檔案的程式碼了，而在 NexT 主題修改的方式其實很類似之前客製化 landscape 主題的做法，只是檔案名稱和位置可能會不同，所以需要另外研究跟適應\n但如果要直接修改原本檔案的程式碼，一樣會建議修改時用註解標記新增了哪些程式碼區段，或是把原本的設定值註解保留，以防後續需要更新主題版本時，無法對照修改了哪些程式碼\n雖然通常不是想用新功能或是網站有出什麼問題，是不會主動去更新主題版本的，所以上面的建議就是一個以防萬一的準備\n接下來就針對需要修改 NexT 主題本身檔案的程式碼時，如何找到該程式碼的檔案位置來做介紹\n\nnjk 檔是什麼？還記得之前 landscape 主題客製化，有介紹到一個統整所有頁面結構的檔案叫 layout.ejs，在 NexT 主題也有這樣的檔案，一樣在 layout 資料夾，但是它的檔名是 _layout.njk\n如果你點開在 themes/next/layout 路徑下的 _layout.njk 檔，你會發現這個 njk 檔的內容和之前介紹的 EJS 樣版語言很類似\n沒錯，它也是一種樣板語言，叫 Nunjucks ( 以下簡稱 njk )，它跟 EJS 一樣可以加入 JavaScript 到 HTML 片段中，也可以引入其他檔案的內容\n只是語法上有些不同，EJS 是用 &lt;%- %&gt; 符號包住程式碼，njk 則是用 &#123;%  %&#125; 包住程式碼，如果想更深入了解這個語言的寫法可以參考 Nunjucks 的官網文件\n\n如何找到要客製的 HTML 程式碼片段這邊會再簡單介紹在 NexT 主題，如何尋找被引入 _layout.njk 的檔案所在位置\n以網站 HTML 的 head 區塊為例，假設我想找到第 4 行被引入的檔案在哪，下圖程式碼可以看見 _partials/head/head.njk 這樣的內容\n\n所以可以知道第 4 行被引入的檔案，在 _partials 內的 head 資料夾，檔名是 head.njk，打開這個檔案就可以看見引入的內容是什麼了\n\n接下來為了驗證，我們回到網站打開發者工具，查看 Elements 中網站的 &lt;head&gt; 起始標籤後第一行，是否和 head.njk 裡的第一行：&lt;meta charset=&quot;UTF-8&quot;&gt; 一樣\n\n看完上面的介紹，是不是覺得和 landscape 主題客製化的做法很像？之後如果需要客製化某個網站部分，也可以依照上面方式查找驗證，然後嘗試修改再觀察網站畫面的變化\n\n如何找到要客製的 CSS 程式碼片段在 NexT 主題中也有類似 landscape 主題的 style.styl 檔，它就是在 themes/next/source/css 路徑下的 main.styl 檔 ( 如下 )\n\n這個檔案可以看到被引入的 styl 檔在哪裡，以 @import &#39;_variables/base&#39;; 來說，引入的檔案是 _variables 資料夾內的 base.styl 檔\n前面有介紹 NexT 主題有 4 種不同的模板樣式，不同模板樣式會有不同的樣式變數，所以當點開 _variables 資料夾，你還會看到其他 4 個以樣式模板名稱命名的 styl 檔案\n\n再對照 main.styl 檔，模板樣式變數的引入位置，是在 base.styl 檔之後 ( 下圖紅框處 ) ，那麼就可以知道後面引入的檔案內容，會覆蓋前面引入的設定內容\n\n也就是說假設你調整了 base 檔的變數設定，卻沒反應可以到你使用的模板樣式變數檔看看，是否有一樣名稱的變數把 base 檔的設定覆蓋了\n了解如何尋找被引入的檔案在哪之後，如果有想客製化修改的樣式，修改步驟就會和 landscape 主題在客製化時的方式很類似\n只要利用開發者工具找到要修改的 CSS 程式碼大約在哪，在回到 main.styl 檔尋找該程式碼可能在哪個檔案中，就可以修改看看、觀察網站樣式是否有變動，如果有的話就恭喜你找到它囉🎉\n補充：styl 檔除了 CSS 之外也可以寫 SCSS 喔 ~ 有 SCSS 就能更有效率的寫網站樣式的程式碼了\n\n補充：languages 資料夾介紹在 next 資料夾中有一個 languages 的資料夾，點開裡面會有各種語言的翻譯文字，繁體中文在 zh-TW.yml 檔內，所以如果有文字翻譯想調整，可以來看看是否有在這個檔案中\n\n結語這篇文章前面主要簡單介紹 NexT 主題的 config 檔在客製化上面有哪些設定，後面才提到如果有直接修改原本檔案的需求時，要怎麼找到想找的程式碼在哪\n我本人比較懶，所以 NexT 主題的 config 檔直接設定一些內容，真的很棒 ~ 如果你正在努力客製 NexT 主題 Hexo 網站，希望這篇文章能幫助你製作出你理想的 Hexo 網站\n那我們就下篇文章見囉 ~\n","categories":["Hexo"],"tags":["前端","Hexo"]},{"title":"JavaScript 修練 (1) | 變數的宣告、作用域與提升","url":"/amy10blog/2025/05/14/20250514-js-learning1/","content":"沒有宣告變數會怎樣？宣告變數的目的在於賦予變數一個初始值，並限制它的作用域。\n在學習 JavaScript 的過程中，總是會一直被重複提醒變數需要被宣告，但是一開始學習 JavaScript 並不會了解為什麼要這樣做，這背後的原因到底是什麼\n這篇文章將介紹有關變數宣告、作用域及提升相關的內容，接下來就用幾個範例，透過比較來了解到底為什麼吧 ~\n沒有宣告的變數會變成全域「屬性」相信在學習過程中常常會聽到有人說：「沒有宣告的變數會變成全域『變數』」，這句話其實嚴格來說不太正確，正確來說是：「沒有宣告的變數會變成全域『屬性』」\n先來比較有宣告的變數 a 及沒有宣告的變數 b，到底有什麼差異\nvar a = 1;b = 2;console.log(window);  // 執行結果如下圖\n\n展開執行結果會發現全域物件也就是 window 裡面，出現了 a 跟 b 兩個屬性\n\n這時候你就會感覺到混亂，所以 a 跟 b 誰是屬性？誰是變數？\n先別急，接著往下走，如果你有一些物件的基礎知識，應該會知道物件內有屬性這個東西，而 window 是一個全域的物件，所以 window 內也會有它的屬性，而沒有宣告的所謂「變數 b」，其實在 JavaScript 眼中是這樣的，前面省略了 window\nwindow.b = 2;\n\n所以你以為你在幫變數賦予值，但其實是在幫 window 這個全域物件新增一個屬性 b 並賦予它值為 2，所以 b 其實是全域的屬性不是變數\n可是用 var 宣告的變數 a 呢？它也在 window 裡面，怎麼證明他們不一樣？\n接下來就派出 delete 這個運算子了，delete 運算子可以用來刪除物件中的屬性，而變數是無法被刪除的，那把它拿來刪除 a 跟 b 會發生什麼事呢？\nvar a = 1;b = 2;delete a;delete b;console.log(window);  // 執行結果如下圖\n\n執行完你會發現 window 裡面的 b 被成功刪除了，但是 a 卻沒有\n\n所以 b 其實是全域 window 屬性，可以使用 delete 刪除它；而 a 在全域環境使用 var 宣告，則為全域變數，無法使用 delete 刪除它\n未宣告的變數其實是全域 window 下的一個屬性不是真的變數，而全域的 window 沒有作用域限制，在哪都可以被存取\n在全域環境下用 var 宣告的變數，雖然是變數但也會在 window 下建立屬性，它並不會被 delete 刪除，所以無論用 window.a 或是用 a 都能取得變數的值\n小補充：let、const 宣告的全域變數這邊補充在全域環境使用 let 或 const 宣告的全域變數，不會在 window 下建立屬性\nvar a = 1;let abc = 3;const abcd = 4;console.log(window);  // 執行結果如下圖\n\n\n\n我就不宣告怎麼樣看了以上這個多解釋，可能還是不太理解到底不宣告變數的後果是什麼，那就讓我們叛逆一次示範一下 (不聽話的下場) 會發生什麼事\n前面有提到未宣告會變成全域屬性，而全域的 window 沒有作用域限制，所以在每個函式和作用域內都可以取得 window 及 window 下的所有屬性\n如果你跟我一樣 剛好是金魚腦，在寫了幾百行程式碼之後可能會發生以下慘劇\nfunction fn() &#123;  family = [];  newMember();  console.log(family);  // [&#123;name: &quot;小美&quot;&#125;]&#125;function newMember() &#123;  family.push(&#123;    name: &quot;小美&quot;  &#125;);&#125;fn();// 中間寫了幾百行程式碼，然後...setTimeout(() =&gt; &#123;  family = &#123;&#125;;  // 這行程式碼把小美家直接清空  console.log(family);  // &#123;&#125;&#125;, 1000);\n\n以上程式碼中 family 在沒有宣告的情況下，它變成了全域屬性，開發時在任何函式中都可以輕鬆呼叫 family，而開發過程中寫了幾百行程式碼後，有可能會忘記定義了哪些全域屬性，所以又用了同樣的名稱來進行開發，結果就是小美家直接變成空物件，程式碼無法運作但你找不到原因\n一個人開發都有可能會因為忘記而出錯，更不要說跟團隊一起開發，未宣告的變數會變成全域屬性，造成全域環境的作用域汙染，導致其他命名覆蓋問題，這可能會導致除錯上的困難\n\n變數的作用域前面提到未宣告變數的後果時，有說到作用域這些詞，接下來就來說說變數的「作用域」( Scope ) 吧 ~\nJavaScript 有一個特別的機制稱為「語法作用域」( Lexical scope )，又稱為「靜態作用域」，意思是原始碼經過直譯器執行後就已經確定了作用域且不會再改變，這讓開發者可以直接透過原始碼了解當前的變數作用域\n簡單來說所謂的語法作用域就是你宣告時就已經決定好他的作用域，而變數宣告後會被限制其作用域，作用域會因為宣告語法不同 ( var、let、const ) 而有變化\n全域變數與區域變數如果舉例來形容全域變數與區域變數，全域變數就像全國的補助、而區域變數則像縣市補助\n\n全域變數 ：全國補助，全國各地都能申請\n區域變數 ：縣市補助，只有在特定縣市內才能申請\n\n兩者作用域範圍不同，全域代表的是最外層，內層可能是各個函式或作用域，而 在內層可以存取在外層宣告的變數，在外層則無法存取在內層宣告的變數\n另外，假設在內層沒有宣告過 b 變數，則會透過「向外查找」的機制，一層一層向外尋找是否有叫 b 的變數，直到最外層全域，如果連全域都沒有 b 變數才會跳出「b is not defined」的錯誤訊息\n接下來看幾個範例\n在外層無法存取在 fn 函式內宣告的區域變數 b\n// 全域變數var a = &#x27;小春&#x27;;function fn() &#123;  // 區域變數  var b = &#x27;小夏&#x27;;&#125;console.log(b);  // Uncaught ReferenceError: b is not defined\n\n在內層 fn2 函式內可以存取在 fn 函式內宣告的區域變數 b\n// 全域變數var a = &#x27;小春&#x27;;function fn() &#123;  // 區域變數  var b = &#x27;小夏&#x27;;  console.log(a, b);  // &quot;小春&quot; &quot;小夏&quot;  function fn2() &#123;    // 區域環境，可存取外層作用域的變數    console.log(a, b);  // &quot;小春&quot; &quot;小夏&quot;  &#125;  fn2();&#125;fn();\n\n\nvar 屬於函式作用域前面一直用 var 在宣告變數，接下來就來說說 var 宣告的變數作用域範圍\n var 的作用域範圍在該函式內 ，在該函式內宣告的變數會被限制在該函式作用域中，也就是該變數只能在該函式中取得，有點像是把變數關在叫做函式的小房間中，變數的活動範圍就被限制了\n以下範例在 fn 函式內被宣告的變數 b，無法在 fn2 函式內被存取\nvar a = &#x27;小明&#x27;;function fn() &#123;  var b = &#x27;杰倫&#x27;;&#125;function fn2() &#123;  var c = &#x27;漂亮阿姨&#x27;;  console.log(b); // Uncaught ReferenceError: b is not defined &#125;fn();fn2();\n\nlet、const 屬於區塊作用域隨著 ES6 成為主流，現在都會建議使用 let、const 來宣告變數，其中 let 宣告的變數可以重新賦值、const 則無法重新賦值\n前面有提到 var 屬於「函式作用域」( function scope )，而 let、const 的作用域則屬於「區塊作用域」( block scope )\n區塊其實就是大括號 &#123;&#125;，前面有比喻函式作用域像是把變數關進叫做函式的小房間，那麼這裡的區塊作用域就像是把變數關進大括號裡面，限制它的活動範圍 ( 變數：結果還是把我關起來了QAQ\n除了前面函式的 &#123;&#125; 大括號可以被認定為是一個區塊之外，還有其他在實戰中常見的區塊作用域：\n\n函式 ：function fn() &#123;...&#125;\nfor 迴圈 ：for(let i=0; i&lt;10; i++) &#123;...&#125;\n判斷式 ：if() &#123;...&#125;\n純粹的區塊 ：&#123;&#125;\n\n其中用常見的 for 迴圈來比較 var 和 let 宣告變數的作用域差異\nfor(var i = 0; i &lt; 10; i++)&#123;&#125;console.log(i);  // 10for(let j = 0; j &lt; 10; j++)&#123;&#125;console.log(j);  // Uncaught ReferenceError: j is not defined\n\n這邊可以看見 var 因為屬於函式作用域，顯然 &#123;&#125; 困不住裡面的變數，所以當在 for 迴圈的小括號中用 var 宣告變數時，這個變數會成為全域變數，或是其他函式內的區域變數 ( 如果迴圈在其他函式內的話 )\n在上面的範例，變數 i 會變成全域變數，在其他地方也能被存取修改，容易汙染作用域環境，而用屬於區塊作用域的 let 宣告，變數的作用域不需要用函式，只要有 &#123;&#125; 就能被限制住，避免產生全域變數，所以使用 let、const 宣告的變數，相對於 var 來說更能避免產生不必要的問題\n\n提升「提升」( Hoisting ) 一詞並未在 ECMAScript 2015 之前的規範中被提到，它通常用於解釋 JavaScript 變數在記憶體中的一種運作形式\n為什麼要把宣告放在前面？學習過程中常常會聽到要先宣告變數賦予值，才能使用該變數，確實先宣告後取用很符合邏輯，但如果不這樣做會發生什麼事呢？先看看幾個範例\n我們知道先宣告變數 a 賦予值為 1，再用 console.log(a) 就能印出 1，但反過來先使用再宣告變數，印出的值為什麼是 undefined\nconsole.log(a);  // undefinedvar a = 1;\n\n這要說到 JavaScript 提升的觀念了，程式碼在瀏覽器執行時分為兩個階段：\n\n創造階段 ( creation ) ：這個階段會準備記憶體空間\n執行階段 ( execution ) ：這個階段才會實際執行程式碼\n\nJavaScript 程式碼在執行過程中，會先進入創造階段準備好記憶體空間存放變數的值，再進入執行階段實際將值賦予到變數上\n而以上程式碼因為在宣告變數前就使用變數，這時候 JavaScript 會開始尋找變數 a，找到確實有宣告變數 a，在創造階段就把變數 a 提升到前方，但因為變數還沒賦值，所以執行階段先執行的 console.log(a) 印出來的是 undefined，最後才執行變數 a 的賦值\n所以以上程式碼其實是這樣的\n// 創造階段var a;// 執行階段console.log(a);  // undefineda = 1;\n\n而 JavaScript 這樣的特性就稱為「提升」，但以上這個範例說明的僅僅是 var 宣告變數時的狀態，如果遇到函式就不一樣了\n相比於 var 宣告的變數，函式在提升上就多了不同的規則：\n\n函式陳述式會提升完整的函式 ：函式陳述式在創造階段的提升會包含整個完整的函式\n函式陳述式優先 ：函式陳述式會優先於變數的提升\n\n等等，怎麼會突然冒出一個「函式陳述式」？\n補充一下，宣告函式時通常有兩種方式：「函式陳述式」與「函式表達式」，這兩種方式寫法不同之外，在提升方式上也不同，先來看看以下範例了解兩者不同的地方\n// 函式表達式var callAnimal = function () &#123;  console.log(&#x27;山羊&#x27;);&#125;// 函式陳述式function callAnimal() &#123;  console.log(&#x27;獅子&#x27;);&#125;callAnimal();  // &#x27;山羊&#x27;\n\n什麼？為什麼執行程式碼的結果是「山羊」？不是「獅子」？這邊一樣用創造、執行階段來拆解程式碼，但要加入函式陳述式的規則：提升完整的函式、優先提升\n// 創造階段// 函式陳述式優先提升到前方function callAnimal() &#123;  console.log(&#x27;獅子&#x27;);&#125;var callAnimal;  // var 宣告的變數在函式陳述式後提升// 執行階段// 執行函式表達式的賦值 ( 將函式賦予到變數上 )callAnimal = function () &#123;  console.log(&#x27;山羊&#x27;);&#125;callAnimal();  // &#x27;山羊&#x27;\n\n透過以上程式碼可以看出兩者在提升上的不同，函式表達式會先宣告變數，再將函式賦予到變數上，而函式陳述式的提升又優先於變數，所以執行的反而是最後才賦值的函式表達式\n因為這樣的不同所以在實戰中大多會擇一使用，但如果希望將函式宣告統一至於後方，那就只能使用函式陳述式方式宣告函式，這樣提升時才是完整的函式\n\nlet、const 的 TDZ前面提到的 var 是 ECMAScript 早期的變數宣告方式，ES6 之後會避免使用 var 宣告，改用 let、const 新的宣告方式，當遇到不明問題時，新語法也能提供適當回饋提示開發者\n前面提到用 var 先取值後宣告，會取得 undefined 的值、不會跳出錯誤訊息，但是用 let、const 如果先取值後宣告，就會出現類似以下的錯誤訊息，提示開發者無法在宣告前取得變數的值\n\n這就是 let、const 宣告才有的「暫時性死區」( Temporal Dead Zone, TDZ ) 特性，在 let、const 宣告變數前方的區域就是 TDZ，如果試圖在這個區域寫入程式碼取得變數值，就會出現 ReferenceError\n\n小補充：undefined 與 is not defined 的差異undefined 與 is not defined 這兩者字面看起來似乎沒有差異，但經過上面的範例示範應該多少可以感覺到兩者的不同\n相信看到這兩者應該還可以再聯想到：null，那這三者又有什麼差異呢？\n這邊簡單的說明三者間的差異：\n\nundefined：是原始型別的一種，在宣告變數時系統預設的空值，開發者應避免手動為變數賦予 undefined 的值\nnull：是原始型別的一種，開發者手動賦予的空值，需要抹除變數已被賦予的值時可以使用 null\nis not defined：是沒有宣告變數卻試圖取得該變數的值時，會跳出的錯誤訊息，這會讓後面的程式碼無法繼續執行，所以要及時修正才不會影響程式碼運作\n\n結語本篇文章介紹了有關 JavaScript 變數宣告、作用域及提升相關的內容，希望能記錄下我學習到的相關內容，同時也希望這篇分享能幫助正在學習 JavaScript 的朋友\n那我們就下篇文章見囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]},{"title":"JavaScript 修練 (2) | 陳述式與表達式","url":"/amy10blog/2025/05/15/20250515-js-learning2/","content":"JavaScript 的文法概念程式語言就像對電腦說的語言，和其他語言一樣也會有自己的文法概念，這些文法形成的語句，會影響電腦對程式碼執行的方式\n本篇文章將介紹陳述式與表達式的差異，而下篇文章也會接續提到關於運算子執行的先後順序，這些都與 JavaScript 的文法相關，而開發中這種文法概念所產生的問題，往往不容易被察覺，所以如果能先了解一些觀念在除錯上也會比較容易發現問題所在，甚至避開可能發生的問題\n陳述式與表達式陳述式與表達式在學習過程中常常被忽略，但其實很常在各種技術文件中出現的專有名詞\n陳述式與表達式在中文翻譯都有其他不同的名稱，但看英文原文就會知道說的是同一個東西，所以開始往下介紹之前，先來定義一下接下來文章的中文用詞：\n\nStatement ：中文翻譯有敘述句、陳述式，接下來文章都統一叫「陳述式」\n\nExpression ：中文翻譯有運算式、表示式、表達式，接下來文章都統一叫「表達式」\n\n\n定義好用詞後，接下來先比較這兩者各自的特點，再來說明常看到的陳述式和表達式有哪些吧 ~\n陳述式陳述式特點如下：\n\n會執行一些程式碼，但是 不會回傳結果\n可能是幾個單詞或一個片段，但不會是單一個字母\n其中可能混合表達式\n\n表達式表達式特點如下：\n\n最大特點是 會回傳結果\n單一個字也可以是表達式\n\n\n哪些是常見的陳述式？\n宣告 ( var、let、const、function )\n流程控制 ( block、if…else )\n迴圈 ( for、for…in )\n其他 ( import、export )\n\n範例說明再來看看幾個範例，實際觀察陳述式在 Chrome 的開發者工具 Console 中會顯示的內容\nvar a; 這個程式片段宣告了一個變數 a，是一個簡單的陳述式，而在 Console 中&lt;・ 符號後面內容代表 Console 回傳的結果，這邊看到這段程式碼結果會是 undefined，代表這段程式碼沒有取得值、不會回傳值\n\n前面提到陳述式可能混合表達式，接下來就來看看混合的範例\n綠框延續上一個單純是陳述式的範例 var a;，黃框處透過運算子 + 計算 2 + 2;，會回傳計算結果 4 所以是表達式，橘框處則是混合綠框與黃框的陳述式，所以 Console 的回傳結果是 undefined\n\nundefined 產生的誤會前面有提到「表達式最大特點是會回傳結果」，這樣陳述式在 Console 回傳的結果是 undefined 就容易因此產生誤會，因為會出現兩種情況：\n\n不會回傳值 ：因為不會回傳值，所以 Console 回傳的結果是 undefined\n會回傳值但沒有提供回傳值 ：此時就算會回傳值，Console 回傳的結果也是 undefined\n\n只看以上說明可能有些抽象，讓我們看看以下範例吧\n\n圖中綠框處 fn1 和 fn2 都是用函是陳述式宣告的函式，所以陳述式在 Console 回傳的結果是 undefined，而呼叫函式會回傳值所以是表達式，而 fn1 函式在綠框片段中有提供回傳值，所以在黃框處呼叫 fn1 函式後，Console 回傳的結果是 &#39;我是 fn1 函式&#39;\n容易產生誤會的片段在橘框，明明呼叫函式是表達式，怎麼 Console 回傳的結果是 undefined？\n往前看綠框片段中的 fn2 並沒有提供回傳值，所以在橘框處呼叫函式時有回傳值，但是因為沒有提供回傳值，所以 Console 才會回傳 undefined\n\n哪些是常見的表達式？\n純值 ( 一個數字 1 也可以稱為「表達式」)\n變數\n運算子\n執行函式\n正規表達式\n函式表達式\nif 小括號內的條件 (condition) 是表達式\n\n範例說明接下來看幾個程式碼範例，然後利用 Chrome 的開發者工具 Console 查看結果\n在 Console 輸入 1，會回傳 1，&lt;・ 符號後面的 1 代表 Console 回傳的結果\n\n再來看看運算子 === 在 Console 中的結果，1 === 1 會回傳 true 的結果\n\n以上兩個範例都會回傳結果，因此純值和運算子計算的結果都屬於表達式\n接下來看看陳述式與表達式混合的範例，以下程式碼中，紅框區塊函式陳述式是陳述式，下面藍框區塊呼叫函式之後回傳了 &#39;我是函式&#39; 的結果，所以呼叫、執行函式為表達式\n\n\n簡單比喻一下陳述式與表達式：陳述式就像只是在講一件要對方做的事，對方只要去做就好不用回應，表達式則像是在問對方問題，希望對方能夠給你回應\n\n表達式運用情境了解陳述式與表達是如何判斷對於閱讀技術文件會有很大的幫助，以前面提到的 if 小括號內的條件 (condition) 是表達式為例\n假設需要知道 if…else 如何使用，在 MDN 文件會看見關於 if…else 說明引用如下：\nif (condition)  statement1// With an else clauseif (condition)  statement1else  statement2\n\n\ncondition：An expression that is considered to be either truthy or falsy\n\n這邊可以說明有提到小括號內的 condition 是一個表達式，而它的結果會是真值或假值，那就可以放心的把任何表達式加入 condition 內，像這樣：\n紅框內呼叫 fn 函式，回傳值為 true，所以會執行 if 大括號 &#123;&#125; 中的程式碼印出 &#39;恭喜通關！&#39;\n\n這時候就會想實驗看看，把陳述式放入 condition，會發生什麼事 (跟你說要放表達式竟然不聽話)\n結果就是會跳出 SyntaxError 的錯誤訊息，把陳述式放入 condition 會造成運作上的錯誤，還是乖乖聽話吧 ~\n\n除了 if 的 condition 之外，還有一些框架使用上會需要了解表達式的概念，像是 React 的 JSX 就有提到大括號 &#123;&#125; 中可以放入 JavaScript 的表達式來運作\n\n函式陳述式與函式表達式前篇有提到這兩者一樣是宣告函式，但是不同語句的差異，遇到提升時卻有不同的運作方式，這篇剛好介紹到了陳述式與表達式 真巧呀，那就再分別對這兩種宣告函式的語句做一些介紹吧 ~\n函式陳述式首先 function 和 var 一樣是關鍵字，可以用來宣告一個函式，而以下範例的宣告方式就屬於陳述式語句\nfunction fn() &#123;  return true;&#125;\n\n陳述式不會回傳值，所以 Console 只會回傳 undefined 的結果\n\n而相同寫法只要在前後加上小括號，就會從陳述式轉變為表達式，這邊可以看到前後加上小括號後，Console 會回傳這個函式本身的結構，此時的函式可稱為「函式表達式」\n\n函式表達式前面提到把函式本身作為表達式使用，回傳的值會是函式的本身，那麼如果我們將這個值 ( 函式本身 ) 賦予到一個變數上，那它就會成為大家所說的「函式表達式」\n將函式表達式回傳的函式賦予給等號 = 左邊的變數\nvar fn = function fn() &#123;  return true;&#125;\n\n延伸討論剛剛提到的 if 小括號內的 condition 必須是表達式，那如果把函式陳述式語句直接放入小括號中 ( 如下 )，程式碼是否還可以運作呢？\nif (function a(p) &#123;&#125;)&#123;  console.log(&#x27;ㄟ嘿！我可以動！&#x27;);&#125;\n\n這邊雖然小括號中的語句看起來是函式陳述式，但是實際上是作為表達式使用，就像前面陳述式前後加小括號轉為表達式一樣，所以程式碼式能正常運作的，而表達式回傳的函式本身會報判斷為真值，所以 console.log 也可以執行喔 ~ 看它可以動多開心\n\n具名函式與匿名函式既然都講到以上兩種函式的宣告語句差異了，那就來接著往下講講函式命名問題吧 ~\n顧名思義，具名函式是有名字的函式，而匿名函式則沒有名字，函式有沒有名字在函式陳述式和函式表達式兩種語句上也有差異\n\n函式陳述式 ：宣告的函式一定要有名字\n函式表達式 ：宣告的函式有沒有名字都可以\n\n接下來看範例比較一下兩者\n// 函式陳述式// function 後方有名字 fn1，這稱為具名函式function fn1() &#123;  return true;&#125;// 函式表達式// function 後方沒有名字，因此稱為匿名函式var fn2 = function() &#123;  return true;&#125;\n\n函式表達式其實也可以在 function 後面加上函式的具名名稱\n// function 後方的 callMe 是函式的名稱var fn2 = function callMe() &#123;  return true;&#125;\n\n但是以上範例的 callMe 這個名稱無法在外部被取得，只能透過變數 fn2 回傳值的方式，或是在 fn2 函式內才能取得\n圖中可以看見紅框處執行 fn2 函式後式可以取得 callMe 這個名稱的，黃框處直接輸入變數名稱 fn2，也可以取得 callMe 這個名稱，但是綠框處試圖在外部取得 callMe，卻跳出 ReferenceError 錯誤，無法取得 callMe 這個名稱\n\n雖然具名的函式表達式名稱，可以在函式內被呼叫，但實戰上不太會有呼叫此函式的需求，所以不太會這樣做\n結語以上是一些關於陳述式與表達式的差異介紹，如果想在更深入了解陳述式及表達式的分類也可以參考以下相關的 MDN 文件：\n\n陳述式與宣告 - Statements and declarations\n運算式與運算子 - Expressions and operators\n\n下篇會再接續本篇，往後介紹運算子執行先後順序的相關內容，那我們就下篇文章件囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]},{"title":"JavaScript 修練 (5) | 型別的顯性與隱性轉換","url":"/amy10blog/2025/05/23/20250523-js-learning5/","content":"轉到你會暈的動態型別前篇提到 JavaScript 的型別不是固定不變的，所以我們可以把字串型別的值賦予在一個變數上，然後重新賦予該變數一個數值型別的值，覆蓋原本的型別，程式在運作時，型別會自動轉換，這也代表我們可以以不同的型別使用同一個變數，而這就稱為「動態型別」\n那麼有靜態型別嗎？有的，像 Java 這種編譯式語言，會先經過編譯後才會執行，在編譯期間會執行型別檢查，確保型別不會在執行時變更，增加程式運作的穩定性，這類就稱為「靜態型別」\n而 JavaScript 屬於直譯式語言，原始碼是由直譯器生成代碼並執行，過程中不會檢查型別，且會在執行過程中動態變更資料型別，因此稱為「動態型別」\n前篇也有提到 JavaScript 的變數沒有型別，值才有，因此變數隨著值的變更，也會同時變更型別，而除了直接重新賦予值之外，也可透過一些方式讓型別轉換\n而轉換方式的類型又分為「顯性轉換」( Explicit Conversion ) 和「隱性轉換」( Implicit Conversion )，這兩者看名字可以知道顯性是使用較明確的方式進行型別轉換，而隱性則是使用其他較不明顯的方式進行轉換，有些隱性轉換手法雖然不明顯無法直接看出轉換原因但是卻很簡短，所以對 JS 較熟練的開發者，也可能因此使用較隱性的方式轉換型別\n只是 JavaScript 規範中，並沒明確描述顯性及隱性的定義，所以何謂顯性、何謂隱性各開發者主觀的認定可能會略有不同，不過大致會以普遍的認知來區別兩者差異，接下來就以「顯性轉換」和「隱性轉換」，來分別介紹 JavaScript 有哪些轉換手法吧 ~\n顯性轉換原始型別包裹物件及原型方法原始型別包裹物件前篇文章提到原始型別包裹物件本身，也可以做為型別轉換的方法使用，其中除了沒有原始型別包裹物件的 null、undefined 之外，Number、String、Boolean、BigInt、Symbol 皆可作為轉換型別使用\nlet produceId = &#x27;111&#x27;;  // produceId 為字串型別let price = 100;  // price 為數值型別// 將 produceId 轉為數值型別console.log(Number(produceId));  // 111console.log(typeof Number(produceId));  // number// 將 price 轉為其他型別console.log(String(price));  // &#x27;100&#x27;console.log(typeof String(price));  // stringconsole.log(Boolean(price));  // trueconsole.log(typeof Boolean(price));  // booleanconsole.log(BigInt(price));  // 100nconsole.log(typeof BigInt(price));  // bigintconsole.log(Symbol(price));  // Symbol(100)console.log(typeof Symbol(price));  // symbol\n\n原型方法前篇也有提到使用 console.dir 印出原始型別包裹物件後，可以在 prototype 這個物件中查看可以使用的方法，而這些原型方法中也有可以轉換型別的方法，如下圖在 Number 包裹物件中展開 prototype 可以找到 toString() 方法\n\n toString() 方法可以將不同型別的值轉為字串型別\n// Number 裡面的 prototype 有 toString 這個方法console.dir(Number);let price = 100;  // price 為數值型別console.log(price.toString());  // &#x27;100&#x27;console.log(typeof price.toString());  // string\n\n但是 null、undefined 這兩個型別，因為沒有原始型別包裹物件，無法使用 toString() 方法轉型為字串型別，所以 String() 相對於未知型別轉換是較穩定的，toString() 遇到特定型別可能會出現錯誤訊息 ( 如下 )\n// undefined 沒有 toString 方法可用，所以會跳出錯誤console.log(undefined.toString());   // VM1630:1 Uncaught TypeError: Cannot read properties of undefined (reading &#x27;toString&#x27;)// String() 方法可以將 undefined 轉為字串型別，不會跳錯console.log(String(undefined));  // &#x27;undefined&#x27;\n\n\n📎補充數值型別轉換\n除了使用 Number 包裹物件之外，還可以用 parseInt() 方法將不同型別的值轉為數值型別，只是兩者轉換上有一些差異，如果要將混有數字跟其他字元的字串轉為數值，Number() 會轉為 NaN ( Not a Number ) 的數值型別結果，但是 parseInt() 則可以將其中的數字轉換為數值型別，範例如下\nconsole.log(Number(&#x27;100元&#x27;));  // NaNconsole.log(Number.parseInt(&#x27;100元&#x27;));  // 100\n\n在全域 window 物件中也有 parseInt 方法，且跟 Number 下的 parseInt 方法一樣，所以省略 parseInt 前面的 Number 也可以運作\nconsole.log(window.parseInt === Number.parseInt);  // true，兩者相同console.log(parseInt(&#x27;100元&#x27;));  // 100\n\nNumber 下的 parseInt 方法\n\nparseInt() 方法是將數值轉為整數，有小數點會直接被去除，所以如果數值有包含小數點，請改用 parseFloat() 進行轉換\nlet str = &#x27;20.6元&#x27;console.log(parseInt(str));  // 20console.log(parseFloat(str));  // 20.6\n\n\n正負運算子 +  -這裡的 +、- 是一元運算子，不是計算左右兩個運算元的二元運算子，更像是數學上用於表示正負值的用法，而不是用於計算結果\n在想轉換的值前方加上 + 或 -，可以將值轉換為數值型別，只是如果字串中含有非數字的字元，就會轉為 NaN，所以相對來說使用 parseInt() 是更穩定的轉數值方法\nconsole.log(typeof(+&#x27;1&#x27;));  // numberconsole.log(+true);  // 1console.log(+&#x27;50元&#x27;);  // NaNconsole.log(-&#x27;50元&#x27;);  // NaNconsole.log(typeof(+&#x27;50元&#x27;));  // number，NaN 也是 number 型別\n\n📎注意：以上轉換數值型別的方式，指的是一元運算子的 + 跟 -，以下範例第一行的 + 是二元運算子 ( 這裡的運作之後會提到 )\n// 二元運算子console.log(1 + &#x27;1&#x27;);  // &#x27;11&#x27;console.log(typeof(1 + &#x27;1&#x27;));  // string// 要正確轉為數值計算，需要在要轉換的字串前補上 +console.log(1 + +&#x27;1&#x27;);  // 2\n\n\n邏輯運算子 NOT !要將不同型別轉換為布林值，可以使用前面提到的包裹物件 Boolean() 來進行轉換，它可以將「真值」轉為 true，「假值」轉為 false ( 什麼是真值、假值後面會提到 )\n但也可以使用更簡單的方式進行轉換，那就是使用邏輯運算子 Not !，! 運算子會將值轉為相反的布林值，也就是原本是真值會轉換成 false，原本是假值會轉換成 true\nconsole.log(!true);  // falseconsole.log(!false);  // trueconsole.log(!0);  // true\n\n那麼聰明的你一定想到了，如果在前面再加上一個 !，!! 雙重驚嘆 是不是就可以讓不同型別的值轉換成原本的布林值了呢？沒錯，所以有時候在實戰上會使用兩個 Not !!，來將值轉換成布林值，示範如下\nconsole.log(!!&#x27;1&#x27;);  // trueconsole.log(Boolean(&#x27;1&#x27;));  // true\n\n\n隱性轉換二元運算子的 +在顯性轉換時有提到，+ 作為一元運算子 ( 正負運算子 ) 使用時，會將運算元轉換為數值型別，而這裡要講的是二元運算子的 +，有兩種用途：\n一種是作為「算術運算子」，用來計算數值 ( 算術運算子不只有 +，後面還會介紹其他 算術運算子)；另一種是作為「字串運算子」，用來連接字串，可以用以下三個規則判斷 + 是屬於哪種用途：\n\n規則一：前後運算元如果其中之一為「字串」型別，+ 視為字串運算子\n規則二：前後運算元如果其中之一為「物件」型別，+ 視為字串運算子\n規則三：上述情況以外，+ 視為算術運算子\n\n簡單總結就是「當前後運算元，其一為字串或物件型別時，+ 為字串運算子」\n\n1. 字串運算子的 +當符合規則一、二，+ 被視為字串運算子時，會先將前後運算元轉型為字串，再將兩個字串連接起來，示範如下\n// 符合規則一：運算元其一為字串型別console.log(1 + &#x27;1&#x27;);  // &#x27;11&#x27;// 符合規則二：運算元其一為物件型別// [] 轉字串為空字串 &#x27;&#x27;console.log(1 + []);  // &#x27;1&#x27;console.log(1 + &#123;&#125;);  // &#x27;1[object Object]&#x27;console.log(1 + function()&#123;&#125;);  // &#x27;1function()&#123;&#125;&#x27;\n\n📎補充物件型別轉字串：物件型別中陣列、物件、函式套用 toString() 轉為字串型別的結果如下方範例\n// [1, 2] 套用 toString() 轉字串結果為 &#x27;1,2&#x27;console.log(1 + [1, 2]);  // &#x27;11,2&#x27;// 任何物件套用 toString() 轉字串結果都是 &#x27;[object Object]&#x27;console.log(1 + &#123;a: 1&#125;);  // &#x27;1[object Object]&#x27;// function()&#123;return 1;&#125; 套用 toString() 轉字串結果為函式本身 &#x27;1function()&#123;return 1;&#125;&#x27;console.log(1 + function()&#123;return 1;&#125;);  // &#x27;1function()&#123;return 1;&#125;&#x27;\n\n\n2. 算術運算子的 +當不符合規則一、二，也就是前後運算元為非字串的原始型別時，+ 為算術運算子，這時會套用 Number() 將前後運算元轉為數值型別，再進行計算相加 ( 如下範例 )\n// 前後為數值計算相加結果為 3console.log(1 + 2);  // 3// 布林值 true 轉為數值是 1，false 則為 0console.log(1 + true);  // 2console.log(false + 2);  // 2// undefined 轉為數值是 NaN，NaN 跟任何數值計算都是 NaNconsole.log(1 + undefined);  // NaN// null 轉為數值是 0console.log(1 + null);  // 1console.log(null + null);  // 0console.log(null + undefined);  // NaN\n\nBigInt 和 Symbol 型別然後你應該會發現上面算術運算子範例，少了原始型別的 BigInt 和 Symbol，沒錯，因為它們比較特殊，會出現例外狀況所以要另外說\n\nBigInt 型別\n當 + 為字串運算子時，BigInt 一樣會轉成字串再連接\n// 符合規則一：運算元其一為字串型別// 1n 轉為字串是 &#x27;1&#x27;console.log(1n + &#x27;1&#x27;);  // &#x27;11&#x27;// 符合規則二：運算元其一為物件型別console.log(1n + []);  // &#x27;1&#x27;console.log(1n + &#123;&#125;);  // &#x27;1[object Object]&#x27;console.log(1n + function()&#123;&#125;);  // &#x27;1function()&#123;&#125;&#x27;\n\n但是當遇到算術運算子時 ( + 以外的算術運算子也是 )，BigInt 不會隱性轉換為數值型別，而是會跳出 TypeError 錯誤，提示 BigInt 無法和其他型別混合使用，需要另外用顯性轉換方式轉型\n\n\nSymbol 型別\nSymbol 型別則是無論 + 是不是算術運算子，都不能用這種方式隱性轉型，值得一提的是，+ 是字串運算子和 + 是算術運算子，跳出的 TypeError 錯誤提示會不太一樣\n當 + 為字串運算子時，會出現無法轉為字串型別的錯誤提示；+ 為算術運算子時，則會出現無法轉為數值型別的錯誤提示，而這剛好可以驗證 + 的用途\n如下圖黃框處錯誤提示是無法轉為 number，可以驗證 + 為算術運算子，紅框處錯誤提示是無法轉為 string，可以驗證 + 是字串運算子\n\n📎補充：Symbol 型別可以轉型成字串、布林，但是不能轉成數值型別\n\n\n\n\n算術運算子 -、*、/講完比較特殊的 + 之後，前面也有說到算術運算子其實不只有 +，還有 -、*、/，用起來就和數學四則運算一樣，可以做加減乘除計算\n算術運算子會將前後運算元套用 Number() 轉型為數值型別，再做計算\nconsole.log(100 - 50);  // 50// 空字串轉數值為 0console.log(100 - &#x27;&#x27;);  // 100console.log(100 - &#x27;50&#x27;);  // 50// 布林值 true 轉為數值是 1，false 則為 0console.log(100 - true);  // 99console.log(false - 50);  // -50// undefined 轉為數值是 NaN，NaN 跟任何數值計算都是 NaNconsole.log(100 - undefined);  // NaN// null 轉為數值是 0console.log(50 - null);  // 50console.log(null - null);  // 0console.log(null - undefined);  // NaN// *、/ 也一樣會轉型為數值型別，再做計算console.log(&#x27;100&#x27; * null);  // 0console.log(50 / true);  // 50\n\n+ 必須不是字串運算子，才會套用 Number() 將運算元轉為數值型別後計算\nconsole.log(1 + &#x27;1&#x27;);  // &#x27;11&#x27;console.log(typeof(1 + &#x27;1&#x27;));  // stringconsole.log(1 - &#x27;1&#x27;);  // 0console.log(typeof(1 - &#x27;1&#x27;));  // number\n\n物件型別轉為數值型別物件型別轉型為數值型別的過程，會先用 toString() 轉型為字串，再用 Number() 轉型為數值，如果字串中有非數字字元就會是 NaN，而 NaN 跟任何數值計算都是 NaN\n// 陣列 [100, 1] 轉為字串是 &#x27;100,1&#x27;，轉成數值是 NaNconsole.log([100, 1].toString());  // &#x27;100,1&#x27;console.log(Number([100, 1].toString()));  // NaNconsole.log([100, 1] * 100);  // NaN// 陣列 [100] 轉為字串是 &#x27;100&#x27;，轉成數值是 100console.log([100].toString());  // &#x27;100&#x27;console.log(Number([100].toString()));  // 100console.log([100] * 100);  // 10000// 任何物件轉為字串都是 &#x27;[object Object]&#x27;，轉成數值是 NaNconsole.log(&#123;&#125; * 100);  // NaN// 以下函式為字串是 &#x27;function fn()&#123;return 1&#125;&#x27;，轉成數值是 NaNconsole.log(function fn()&#123;return 1&#125; * 100);  // NaN\n\n例外狀況這邊例外狀況前面有稍微提到，就是 BigInt 和 Symbol 這兩個型別，BigInt 型別不能和其他型別混合計算，若 BigInt 型別要與數值型別計算，要先把 BigInt 轉成數值型別再計算，才不會跳錯，而 Symbol 型別則是無法用這種方式隱性轉型再計算\n// BigInt 型別不能和其他型別計算，僅能與 BigInt 型別計算console.log(1n * 100);  // Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversionsconsole.log(1n * 100n);  // 100n// 若要與數值型別計算，BigInt 要先顯性轉型成數值再計算console.log((Number(1n)) * 100);  // 100// Symbol 型別無法用這種方式隱性轉型再計算console.log(100 * Symbol(1));  // Uncaught TypeError: Cannot convert a Symbol value to a number\n\n結語本篇文章介紹了 JavaScript 在型別轉換分成顯性及隱性轉換，也分別針對兩種轉換介紹了各種轉換型別的方式及規則，希望下次在遇到型別轉換時，大家都能更了解背後的規則\n那我們就下篇文章見囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]},{"title":"JavaScript 修練 (3) | 運算子執行先後","url":"/amy10blog/2025/05/21/20250521-js-learning3/","content":"運算子前篇文章有提到表達式 ( Expression ) 會回傳值，而除了純值、呼叫函式之外，運算子 ( Operator ) 執行時也會回傳值，所以 MDN 文件把表達式和運算子放在同一章節內是有道理的\n等號運算子也會回傳值我們知道等號運算子 = ( Assignment Operator ) 是將右側的值賦予到左側變數上，但看開發者工具的 Console 執行結果，會發現它也會回傳值\n\n🔮如果是 var a = 1; 則不會回傳值，雖然後方 a = 1 是表達式，但前篇有提過用 var 宣告會讓這行程式碼被判斷為陳述式，所以最終不會回傳值\n補充：Assignment Operator 中文翻譯有指派運算子、指定運算子\n運算子與運算元運算子是由一個符號或單字組成，且至少要搭配一個運算元才能執行，所以我們常常會聽到的「一元」、「二元」、「三元」運算子，就是在說這個運算子的運算元數量\n以下方的 + 運算子為例，而左右兩個數字是運算元，所以它是「二元運算子」\n\n大部分運算子都是「二元運算子」，且都是以符號形式為主，如算數運算子 ( Arithmetic Operator )： +、-、*、/，此外也有「一元運算子」和「三元運算子」\n一元運算子前面提到的 delete 就是一元運算子，它是以 delete 這個單字為運算子，搭配後方的運算元組成，執行過程中會刪除物件下的一個屬性，同時也會回傳刪除的結果 ( 下圖紅框處 )\n\n另外 typeof 也是一元運算子，它可以用來取得運算元的型別\n\n三元運算子三元運算子只有一個，也稱為「條件運算子」，它由兩個運算子 ?、: 和三個運算元組成，會由 ? 左邊判斷式的真假值決定要執行 : 左邊或右邊的表達式，然後回傳一個結果，寫法示範如下\n// 判斷式 ? 真值時執行的表達式 : 假值時執行的表達式1 === 1 ? &#x27;相等&#x27; : &#x27;不相等&#x27;;\n\n因為 1 === 1 為 true，所以執行 : 左邊的表達式，回傳值為 &#39;相等&#39;\n\n和前篇介紹的 if 判斷式很類似，但寫法與執行還是有差異，它不僅可以作為判斷用，也可以用來回傳最終執行結果\nconst isSleeping = true;const result = isSleeping ? &#x27;睡覺中，請勿打擾&#x27; : &#x27;醒了，請吵我&#x27;;console.log(result);  // &#x27;睡覺中，請勿打擾&#x27;\n\n無論是哪一種類型的運算子，都要記得「運算子屬於表達式的一種」( 會回傳值 )\n運算子位置影響回傳和賦值先後學習運算子 ++ 的過程中，一定有看過類似 ++a、a++ 這兩種寫法，放前面跟放後面有差嗎？答案是有的，但是不一定每次都能看出它們的差異，所以可能會被忽略，導致當這樣的差異影響到程式碼的結果時，找不出原因在哪\n部分運算子在執行過程中不會影響原始值，如：前面提過的 + 運算子，雖然會進行計算，但除非將結果另外用等號賦值，否則不會變更到變數的原始值\nvar a = 1;console.log(a + 1);  // 2// + 運算子沒有變更 a 的原始值console.log(a);  // 1\n\n但也有運算子在執行過程中會影響原始值，如：開頭說的 ++ 運算子，它屬於一元運算子，在它前方或後方加入一個值為數值的變數作為運算元，就可以讓該運算元變數的值增加 1\n以下兩組程式碼，差異只有第二行 ++ 運算子放在 a 變數前或後，但無論前後都會影響變數原始值讓它增加 1，所以變數 a 的值最後都被賦予為 2\nvar a = 1;console.log(++a);  // 2console.log(a);  // 2\n\nvar a = 1;console.log(a++);  // 1console.log(a);  // 2\n\n仔細看會發現雖然最後 a 的值都是 2，但是 ++a 跟 a++ 兩者用 console.log 印出的結果卻不同，這是因為 ++ 運算子放在運算元前方或後方，會影響它回傳值的時機點\n\n++ 在前方：會先計算並賦值，然後才會回傳運算元的變數值\n++ 在後方：會先回傳運算元的變數值，然後才會計算並賦值\n\n因此，隨然最後都會改變變數 a 的值，但是執行順序的不同，就會導致程式碼運作的不同，接下來看看幾個範例，實際比較兩者運作上的差異吧 ~\n以下兩組程式碼就是因為回傳時機點不同，而導致 *10 的計算結果不同，第一組程式碼是將 a 的值 +1 後，才執行計算 *10，第二組則是先用 +1 前的 a 值和 *10 計算 ( 1 * 10 )，再將 a 的值 +1\nvar a = 1;// a++ 會先回傳值 1，跟後面的 * 10 計算，然後再把 a + 1 的計算結果賦值給 a，所以 b 的值是 10const b = a++ * 10;console.log(b);  // 10\n\nvar a = 1;// ++a 會先 a + 1 的計算結果賦值給 a，再回傳值 2，然後跟後面的 * 10 計算，所以 b 的值是 20const b = ++a * 10;console.log(b);  // 20\n\n小試身手那麼經過上面的說明，試試看你能不能回答以下三個 console.log 印出的結果吧 ~\nvar a = 1;console.log(a++);console.log(a);console.log(++a);\n\n以上程式碼中 a++ 會先回傳變數 a 的值，所以 console.log(a++); 印出的結果不是計算賦值後的結果，是 a 計算前的值 1，而 console.log(a); 印出的結果，才是前面計算賦值後的結果 2，最後 ++a 會先計算並賦值，再回傳變數 a 的值，所以 console.log(++a); 印出的結果是計算後的結果 3\n回傳值不一定是賦值前面提過等號運算子，可以讓 = 右側的值賦予到左側，而且會回傳一個新值，而很多時候我們會誤以為賦值一定會成功，「回傳的值」在我們心裡跟「賦予的值」默默畫上了等號，但是這兩個值並不一定會相等 ( 直接心碎 QAQ，就像以下範例\n// 定義 obj 物件，在裡面加入屬性 valueconst obj = &#123;  value: 1&#125;// 用 Object.freeze() 凍結物件Object.freeze(obj);// 重新將 obj.value 賦值為 2，會回傳的值為 2obj.value = 2;  // 2// 賦予給 obj.value 的值還是 1console.log(obj.value);  // 1\n\n下圖是執行以上程式碼的結果，可以看到當執行 obj.value = 2; 回傳的值為 2，因為 obj 物件內的屬性 value 無法被更動，所以就算重新賦值，obj.value 的值還是 1，但是紅框處的回傳值卻不是 1 而是 2，因此等號回傳的結果不一定與賦予值相等\n\n連續賦值產生的問題既然前面提到了賦值，那就順便說說連續賦值會產生的問題吧 ~ 先看看以下範例，newValue 的最終值是 1 還是 2 呢？\nconst obj = &#123;  value: 1&#125;Object.freeze(obj);const newValue = obj.value = 2;console.log(newValue);  // ？\n\n依照前面講的等號執行順序，應該是先執行 obj.value = 2，把右邊的值 2 賦予給 obj.value，再執行 newValue = obj.value，把 obj.value 的值賦予給 newValue，然後因為 value 無法被更動，所以答案是 1 對吧？\n很遺憾答錯了… 答案是 2，這時候一定覺得滿頭問號，為什麼？\n現在就來重新拆解上方程式碼的執行流程：\n\n執行 obj.value = 2，這時候會回傳一個新值 2\n執行 newValue = 2，而這個 2 就來自於流程 1 回傳的值，所以 newValue 的值跟 obj.value 的值根本無關\n\n\n中間的部分就算無法被賦值，賦予值的行為也還是會繼續進行，這就是要避免在實戰中連續賦值的原因，它可能會給你帶來意想不到的結果 (除非你喜歡驚嚇不然請避免這樣寫\n其中在 ESLint 中 no-multi-assign 的內容就有提到不要連續賦值的範例如下，當連續賦值時，其實只有左側的變數 a 有被宣告，中間的變數 b 則會因為沒宣告變成全域屬性，所以在外層作用域也可以取得 b 的值\n(function() &#123;    const a = b = 0;    b = 1;&#125;)();console.log(b);  // 1console.log(window);  // 印出結果如下圖，b 變成全域屬性\n\n\n優先序與相依性我們在學數學四則運算時，老師總會說要「先乘除後加減」，所以當看到 4 + 2 * 3，我們會習慣先處理後面的 2 * 3，再將結果 6 與 4 相加，得出結果為 10\n這個算式在 JavasScript 中得出的結果也是 10，這邊我們會發現其實 JavasScript 在執行時也有優先順序的概念，這樣的概念不僅限於數學符號，而是所有運算子都會依據此優先順序執行\n\n而 JavasScript 中的「運算子優先序」( Operator precedence ) 就是用來決定執行先後順序的，優先序較高的運算子就會優先執行，上述的的例子中 * 運算子優先序就高於 + 運算子\n另外還有一個「相依性」( Associativity ) 則用於決定執行的方向性，通常會認為程式碼是由左向右執行，但是其實也有許多運算子是由右向左執行的，如上面提到的等號運算子就是由右向左執行\n而「優先序」與「相依性」會影響整段程式碼的執行結果，如果沒有它們決定執行順序，那麼 JavasScript 執行的概念會大亂，另外在 MDN 文件上也有表格，整理各個運算子的優先序與相依性可以參考\n接下來來看幾個範例，觀察優先序與相依性如何影響程式碼執行順序\n以下範例中，= 運算子優先序低於右側的 * 和 + 運算子，所以會先執行右側結果，而 * 運算子優先序高於 + 運算子，所以計算結果為 7，接下來再執行 = 把右側結果 7 賦值給左側的 a，所以 a 的值為 7\nconst a = 3 + 2 * 5;\n\n接下來看一個比較的範例，兩行程式碼如果以我們固有的思考方式，會覺得兩個都應該回傳 true，但是對 JS 來說這兩行程式碼執行之後的結果卻不同\n1 &lt; 2 &lt; 3;  // 回傳 true3 &gt; 2 &gt; 1;  // 回傳 false\n\n兩行程式碼看似相同結果卻不同，所以跟連續賦值一樣，連續比較也是不建議在實戰中出現的寫法，那麼就來看看這兩行程式碼實際時怎麼執行的吧 ~\n第一行 1 &lt; 2 &lt; 3;\n\n&lt; 運算子的相依性是由左向右執行，1 &lt; 2 會得到 true 的結果\n再來執行 true &lt; 3，true 會轉型為數字 1，而 3 大於 1，所以結果為 true\n\n第二行 3 &gt; 2 &gt; 1;\n\n&gt; 運算子的相依性是由左向右執行，3 &gt; 2 會得到 true 的結果\n再來執行 true &gt; 1，1 不大於 1，所以結果為 false\n\n看完上面兩行程式碼的實際執行，就會發現 1 &lt; 2 &lt; 3; 會回傳 true，只是個美麗的誤會，實際上並不會照我們期望的那樣比較，而是一步一步按照相依性規則執行比較的結果\n結語前面有提到運算子屬於表達式的一種，結合前篇文章表達式會回傳值的概念和以上程式碼示範，可以觀察到表達式的回傳值會影響前後文的運作，鏈式寫法雖然比較精簡，但還是要了解其中執行先後的概念，才能避開不如預期的錯誤或結果\n那我們就下篇文章見囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]},{"title":"JavaScript 修練 (6) | 比較時的型別轉換與真值假值","url":"/amy10blog/2025/05/24/20250524-js-learning6/","content":"前置知識前篇文章講了很多情況的型別轉換，而在比較時的型別轉換又是不同的規則，開始講解規則之前先介紹一些基礎知識：嚴格相等與寬鬆相等、真值與假值\n\n嚴格相等與寬鬆相等\n兩種相等的運算子符號差在等號數量，實戰中會建議使用三個等號 ===，避免不如預期的結果，從以下兩者介紹中寬鬆相等 == 不用連型別都一樣，那麼前後運算元型別不同要如何比較呢？寬鬆相等會比較轉型後的結果，比較時的型別轉換規則就從這裡展開\n\n嚴格相等 ===：值與型別，完全相等才能回傳 true，對應的不相等符號是 !==\n寬鬆相等 ==：值相等就回傳 true，型別不需要相等，對應的不相等符號是 !=\n\n\n真值與假值\n在 JavaScript 中，任何值用 Boolean 轉換型別的結果，不是 true 就是 false，所以可以把 JavaScript 中的值分成兩種「值」：真值、假值\n\n假值 ( falsy )：轉換為布林後會變成 false 的值\n真值 ( truthy )：其他會變成 true 的值\n\n真值很多，所以只要記假值就好，除假值之外其他都是真值，以下是 MDN 整理的假值表格\n\n\n\n講完一些基礎知識之後，接下來就分別來介紹嚴格相等和寬鬆相等比較，以及真值假值的相關內容吧 ~\n嚴格相等 ===嚴格相等比寬鬆相等更單純，值和型別都相等才能回傳 true，但是還是有一些容易搞混的嚴格相等範例\n// 以下結果為 falseconsole.log(NaN === NaN);  // 因為 NaN 不等於 NaNconsole.log(undefined === null);  // 這是兩個不同的型別console.log(&#123;&#125; === &#123;&#125;);  // 左邊的物件實體和右邊的物件實體不是同一個實體console.log([] === []);  // 左邊的陣列實體和右邊的陣列實體不是同一個實體console.log(new Number(0) === new Number(0));  // 前篇說過這樣建立的 number 會變成物件型別，所以左右是兩個不同的實體// 以下結果為 trueconsole.log(+0 === -0);\n\n📎補充 NaN 特性：NaN ( Not a Number) 雖然不是數字，但是它的型別是 Number 型別，NaN 不等於任何值，包括它自己 ( 三個等號跟二個等號都不相等 )，NaN 跟任何數值計算都是 NaN 一直覺得 NaN 很像病毒，它會傳染耶\n寬鬆相等 ==寬鬆相等的規則就比較複雜，前面有提到寬鬆相等只要值相等就可以回傳 true，前後運算元的型別不同時，就會比較轉型後的結果，而其中每種型別轉換比較的規則都不大一樣\nNumber、String、Boolean 型別這三者之間在進行寬鬆相等的比對時，通通都會轉為 Number 型別再比較，如：\nconsole.log(Number(&#x27;a&#x27;));  // NaN// NaN 等於任何值也不等於自己console.log(&#x27;a&#x27; == true);  // falseconsole.log(&#x27;a&#x27; == false);  // falseconsole.log(&#x27;a&#x27; == 1);  // false// 其他混合比較console.log(&#x27;1&#x27; == true);  // trueconsole.log(1 == &#x27;1&#x27;);  // trueconsole.log(&#x27;0&#x27; == false);  // true\n\nNull、Undefined 型別這兩者進行寬鬆相等的比對時幾乎不會轉型，null 和 undefined 除了跟自己相比，或兩者彼此相比結果是 true 之外，其他結果都為 false\nconsole.log(null == 0);  // falseconsole.log(null == &#x27;&#x27;);  // falseconsole.log(null == false);  // falseconsole.log(undefined == 0);  // falseconsole.log(undefined == &#x27;&#x27;);  // falseconsole.log(undefined == false);  // falseconsole.log(null == undefined);  // trueconsole.log(null == null);  // trueconsole.log(undefined == undefined);  // true\n\nBigInt 型別任何值與 BigInt 型別進行寬鬆相等的比對時，都會轉型為「數學值」( mathematical value )，這裡說的數學值並不是指 Number 型別的值，實際比較時也可以理解為「和 BigInt 型別比較的值會轉型為 BigInt」，而與 Number 型別的值相比數學值具有以下特性：\n\n沒有 NaN\n沒有小數點\n沒有最大值\n\n除以上三點，數學值的其它概念與 Number 型別的值接近\n上面有提到最大值的概念，Number 型別其實有最大安全值，在 Number 包裹物件中的 MAX_SAFE_INTEGER 這個屬性就可以查看該值，當大於這個值計算精準度就會下降\n\n// Number 的最大安全值 MAX_SAFE_INTEGERconsole.log(Number.MAX_SAFE_INTEGER); // 9007199254740991// 單純用 Number 與 String 型別比較，會因為超出最大安全值而不精準console.log(9007199254740991 == &#x27;9007199254740991&#x27;); // trueconsole.log(9007199254740993 == &#x27;9007199254740992&#x27;); // true// 改用 BigInt 與 String 型別比較，不受最大安全值影響console.log(9007199254740993n == &#x27;9007199254740992&#x27;); // falseconsole.log(9007199254740993n == &#x27;9007199254740993&#x27;); // true\n\n遇到帶有小數點的 Number 型別值時，因為 BingInt 沒有小數點，所以結果會是 false，遇到 NaN 則因為 NaN 不等於任何值，所以結果為 false\n// Number 型別轉為 BingInt 型別比較console.log(100 == 100n);  // true// BingInt 沒有小數點console.log(100.5 == 100n); // false// NaN 不等於任何值console.log(NaN == 100n); // false\n\nSymbol 型別Symbol 型別建立的值是唯一的，運作有點類似物件的「傳參考」特性，所以一樣的值，無論嚴格或寬鬆相等比對結果都是 false\n// 類似物件與物件比對的運作let s1 = Symbol(2);let s2 = Symbol(2);console.log(s1 == s2);  // falseconsole.log(s1 === s2);  // falseconsole.log(Symbol(2) == Symbol(2));  // falseconsole.log(Symbol(2) === Symbol(2));  // false\n\n注意以下範例會得到 true 的結果，運作和物件與物件比對很相近，這邊實際上只有建立一個 Symbol，s1 和 s2 是共用同一個記憶體位置\n// s1 和 s2 共用一個記憶體位置let s1 = Symbol(2);let s2 = s1;console.log(s1 == s2);  // trueconsole.log(s1 === s2);  // true\n\n\n物件型別與原始型別比較前面提到 Symbol 型別比較的運作，很類似物件與物件比對的運作，會使用參考位置的方式比較，但物件型別與原始型別比較卻有不同規則，當物件型別與原始型別進行寬鬆相等比較時，JavaScript 會嘗試將物件型別轉換為與原始型別相同的型別，再進行比較\nNumber、String、BigInt 型別物件型別與這三種原始型別比較時，物件型別會嘗試轉換為與原始型別相同的型別，可以想成是用包裹物件 Number、String、BigInt 進行型別轉換後，再進行比較，這邊會以陣列為主要範例\n\n物件型別 vs Number 型別：陣列 [100] 轉為 Number 型別是 100，所以結果為 true\nconsole.log([100] == 100);  // true\n\n物件型別 vs String 型別：陣列 [&#39;x&#39;, &#39;y&#39;] 轉為 String 型別是 &#39;x,y&#39;，所以結果為 true，補充任何物件轉為 String 型別都是 &#39;[object Object]&#39;，所以 &#123;&#125; == &#39;[object Object]&#39; 結果為 true\nconsole.log([&#x27;x&#x27;, &#x27;y&#x27;] == &#x27;x,y&#x27;);  // true// 任何物件轉為字串都是 &#x27;[object Object]&#x27;console.log(&#123;&#125; == &#x27;[object Object]&#x27;);  // true\n\n物件型別 vs BigInt 型別：陣列 [&#39;100&#39;] 和 [100] 轉為 BigInt 型別都是 100n ( 可以用 BigInt 包裹物件轉換型別查看結果 )，所以結果為 true\nconsole.log([&#x27;100&#x27;] == 100n);  // trueconsole.log([100] == 100n);  // true// BigInt 不受最大安全值影響console.log([&#x27;9007199254740992&#x27;] == 9007199254740993n); // falseconsole.log([&#x27;9007199254740993&#x27;] == 9007199254740993n); // true\n\nNull、UndefinedNull 或 Undefined 型別本身沒有對應的包裹物件，物件型別也就不會轉換成 Null 或 Undefined 型別，所以物件型別與 Null 或 Undefined 型別比較的結果為 false\nconsole.log([] == null);  // falseconsole.log(&#123;&#125; == null);  // falseconsole.log([] == undefined);  // falseconsole.log(&#123;&#125; == undefined);  // false\n\n例外情況\nBoolean 型別：物件型別與布林做比較，布林會轉為 Number 型別，物件型別也會轉為 Number 型別，再做比較\n\n// [] 轉為 Number 型別是 0，true 轉為 Number 型別是 1，false 則為 0console.log([] == false);  // trueconsole.log([1] == true);  // trueconsole.log([2] == true);  // false// &#123;&#125; 轉為 Number 型別是 NaN，NaN 不等於任何值console.log(&#123;&#125; == true);  // false\n\n📎物件型別與 Symbol 型別進行比較時，不是結果為 false，就是拋出無法轉型的錯誤，因此不建議直接讓物件或陣列與 Symbol 進行比較，因為幾乎不會得到 true，反而容易出現錯誤\n真值與假值的應用真值與假值在實戰中，常會用於 if 判斷值是否存在、是否不為 0、是否不為 null 或 undefined，嚴格來說是判斷該值是否為「真值」，看看以下的範例應用\n變數 a 有被賦予值 &#39;我是 a&#39;，所以 if 判斷 &#39;我是 a&#39; 為真值，所以會運行完整的陳述式，若變數 a 的值是 null 或 undefined，則不會執行 console.log(&#39;可運行&#39;); 這行程式碼\nlet a = &#x27;我是 a&#x27;;if(a)&#123;  console.log(&#x27;可運行&#x27;);  // &#x27;可運行&#x27;&#125;\n空的陣列 [] 是真值，若希望陣列內沒東西要被視為假值，可以在陣列後加上 .length，當長度為 0 就為假值，也就不會運行完整的陳述式了\n// [] 是 true，console.log 會運行if([])&#123;  console.log(&#x27;可運行&#x27;);  // &#x27;可運行&#x27;&#125;// [].length 是 false，所以 console.log 不會運行if([].length)&#123;  console.log(&#x27;可運行&#x27;);&#125;\n\n當然真值與假值在實戰中並不只限於 if，也有其他應用，像是搭配三元運算子或邏輯運算子 &amp;&amp;、|| 來使用，接下來看幾個結合運算子的真值、假值應用範例\n\n三元運算子\n在 if 判斷式結構相對單純的情況下，可以改用三元運算子方式撰寫條件判斷的程式碼，能讓程式碼看起來更簡潔，增加閱讀性\n// if 判斷式let message;let isLoggedIn = true;if(isLoggedin) &#123;  message = &#x27;歡迎回來！&#x27;;&#125; else &#123;  message = &#x27;請先登入&#x27;;&#125;console.log(message);\n\n// 三元運算子let isLoggedIn = true;let message = isLoggedIn ? &#x27;歡迎回來！&#x27; : &#x27;請先登入&#x27;;console.log(message);\n\n邏輯運算子 AND &amp;&amp;\n若要陣列有資料才執行程式，就可以用 list.length 取得陣列長度，再搭配邏輯運算子 &amp;&amp;，如果陣列中沒有資料，長度就會是被視為假值的 0，這時候就不會觸發 &amp;&amp; 後的 console.log 執行\nconst list1 = [];list1.length &amp;&amp; console.log(&#x27;有資料！&#x27;);const list2 = [1, 2];list2.length &amp;&amp; console.log(&#x27;有資料！&#x27;);  // &#x27;有資料！&#x27;\n\n邏輯運算子 OR ||\n若函式沒有帶參數，則參數值為 undefined，這可能會影響函式內程式碼的運作，而透過搭配邏輯運算子 ||，可以將被視為假值的 undefined 賦予一個預設值，避免錯誤\nfunction fn(num)&#123;  var newNumber = num || 100;  // 預設值 100  console.log(newNumber);&#125;fn();  // 100\n\n補充「AND &amp;&amp;」和「OR ||」經過上方的範例可以發現運算子「AND &amp;&amp;」和「OR ||」，雖然字面意思是「且」跟「或」，感覺好像應該要回傳 true 或 false 這樣的布林值\n但在 JavaScript 中它們回傳的值不一定是布林值，而是兩個運算元中的其中一個\n這兩個邏輯運算子都會從左至右檢查運算元的值，並將每個運算元先轉為對應的布林值（truthy &#x2F; falsy）進行邏輯判斷，再決定要回傳哪個原始值：\n\n&amp;&amp;（AND 運算子）  如果第一個運算元為 falsy，代表結果已經是 false，所以會直接回傳第一個值，不再判斷後面；否則會繼續判斷第二個值，並回傳第二個值\n\n||（OR 運算子）  如果第一個運算元為 truthy，代表結果已經是 true，所以會直接回傳第一個值，不再判斷後面；否則會繼續判斷第二個值，並回傳第二個值\n\n\n而這樣的機制稱為短路求值（Short-circuit evaluation），正因為有這樣的機制，我們才能更簡潔地設定預設值、執行條件判斷的程式碼或避免錯誤\n不是！你不是假值嗎？前面有提到真值很多，所以只要記假值就好，除假值之外其他都是真值，但就是會遇到那種讓人誤會滿滿的值，開始看以下範例前，建議再好好看一下假值的表格\nconsole.log(Boolean([]));  // trueconsole.log(Boolean(&#123;&#125;));  // trueconsole.log(Boolean(&#x27;0&#x27;));  // trueconsole.log(Boolean(&#x27; &#x27;));  // trueconsole.log(Boolean(new Number(0)));  // trueconsole.log(Boolean(new Boolean(false)));  // true\n\n沒錯，以上結果都是 true，它們都是真值 ( 真到讓你懷疑人生 )，空陣列跟空物件仔細看表格就會發現它們不是假值，而字串除了空字串是假值之外，字串內有任何值 ( 包含空白字元 ) 就是真值，再來最後兩個用 new 運算子搭配包裹物件建立的原始型別值，會變成物件，所以很遺憾它們也是真值\n結語本篇文章介紹了嚴格相等、寬鬆相等，以及寬鬆相等比較時型別的轉換規則，最後也補充了真值與假值在實戰上的應用方式，型別轉換在 JavaScript 這門語言算是很重要的概念，理解轉換的規則在開發也能避開錯誤，希望大家看完三篇與型別相關的文章可以功力大增\n那我們下篇文章見囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]},{"title":"JavaScript 修練 (4) | 型別判斷與原始型別包裹物件","url":"/amy10blog/2025/05/22/20250522-js-learning4/","content":"強型別與弱型別開始介紹 JavaScript 中型別有哪些和判斷的方式之前，我想先介紹一些強型別與弱型別的基礎知識，程式語言中依語言型別系統 ( Type system ) 分成「強型別語言」與「弱型別語言」兩種\n\n強型別：程式所定義的變數型別等於變數在執行時的型別，在宣告變數時必須指定一種資料型別給它\n弱型別：不需要在宣告變數時指定資料型別，雖語法較簡潔，但要注意型別轉換所產生的非預期結果\n\nJavaScript 是弱型別語言那麼 JavaScript 經過前幾篇文章的程式碼，可以很明顯發現宣告變數時只是直接賦予值，就開始使用這個變數了，並不需要指定資料型別給變數，所以我們可以知道 JavaScript 屬於「弱型別」語言\n可是不需要指定型別，JavaScript 的型別是怎麼來的？JavaScript 的型別只在值本身，而非透過變數帶來資料型別的資訊，也就是說「變數沒有型別，值才有」\n不用指定型別不是少一件事要做，也挺好的不是嗎？但是 JavaScript 沒有這麼單純，它的型別不是固定不變的，你可以透過一些方式讓變數的值轉換型別，這對於習慣撰寫強型別語言的開發者來說，簡直就是災難 調皮的 JavaScript\n這表示如果不熟悉 JavaScript 型別轉換背後的規則，將可能在執行程式碼時產生不如預期的結果，至於哪些情況會讓型別發生轉換，就是這篇文章將提到的主要內容\nJavaScript 的型別與判斷在開始說明型別轉換之前，首先要先認識 JavaScript 有哪些型別，JavaScript 的型別主要區分為兩大類：「原始型別」( Primitives，也稱為基本型別 ) 與「物件型別」( Object )\n原始型別以下七種型別屬於原始型別，這邊就不細說每個型別的特徵，只專注在介紹型別判斷的內容，若想深入了解每個型別可以參考 MDN 的文件\n\nString ( 字串 )\nNumber ( 數值 )\nBoolean ( 布林 )\nUndefined\nNull\nBigInt\nSymbol\n\n物件型別Object：不屬於原始型別的，都屬於物件型別\n🔮只要不屬於原始型別，就會被歸類為「物件型別」，所以沒有什麼陣列型別或函式型別，不是原始型別就是物件型別\n判斷型別的方式想知道一個值屬於原始型別還是物件型別，只需要記得一個重點「物件型別可以自由新增屬性，但是原始型別不行」，接下來看看幾個範例\n物件型別可以自由新增屬性物件、陣列、函式屬於物件型別，試著新增屬性\n\n物件：物件本身就有新增屬性的功能，印出 person 物件可以看見新增的 name 屬性，也能夠存取到物件內的 name 屬性值為 &#39;小夏&#39;\nconst person = &#123;&#125;;person.name = &quot;小夏&quot;;console.log(person);  // &#123;name: &#x27;小夏&#x27;&#125;console.log(person.name);  // 小夏\n\n陣列：雖然根據印出結果可以看見陣列內確實有新增的 name 屬性，可以運作，但實戰中請不要這樣做，陣列有它自己的運作方法，這樣奇怪的結構可能會造成一些操作問題\nconst arr = [];arr.name = &quot;可愛的陣列列&quot;;arr.push(1);console.log(arr);  // [1, name: &#x27;可愛的陣列列&#x27;]console.log(arr.name);  // 可愛的陣列列\n\n\n\n函式：因為函式本身已經有 name 屬性了，為了不覆蓋它，改為新增 myName 屬性，可以用 console.log 取得屬性值，但是看不見 fn 函式裡面的內容，所以要改用 console.dir，強制它使用物件結構展示，就可以看到 fn 函式變成一個可展開的物件，展開後可以看見裡面有剛新增的 myName 屬性\nconst fn = function() &#123;&#125;;fn.myName = &quot;小春&quot;;console.log(fn.myName);  // 小春console.log(fn);  // ƒ () &#123;&#125;console.dir(fn);  // 下拉展開可以看到 myName 屬性\n\n\n\n\n原始型別無法新增屬性相反的，原始型別無法新增屬性，以下方原始型別中的 number 數值型別來說，新增屬性不會跳錯，但是無法取得 myName 的值，而且無論用 console.log、console.dir 都只會印出數值 1\nlet num = 1;num.myName = &quot;我是數字 1&quot;;console.log(num.myName);  // undefinedconsole.log(num);  // 1console.dir(num);  // 1\n\n\n🔮如果試圖在 null、undefined 內新增屬性，會跳出 TypeError 的錯誤\n\ntypeof 的例外相信講到判斷型別，一定會有人第一時間想到前篇提到的一元運算子 typeof，沒錯！它會回傳運算元的型別，但是有一些例外狀況\n// 原始型別console.log(typeof &quot;沒騙你！我是字串&quot;);  // stringconsole.log(typeof 1);  // numberconsole.log(typeof true);  // booleanconsole.log(typeof undefined);  // undefinedconsole.log(typeof null);  // objectconsole.log(typeof 5n);  // bigintconsole.log(typeof Symbol(1));  // symbol// 物件型別console.log(typeof &#123;&#125;);  // objectconsole.log(typeof []);  // objectconsole.log(typeof function()&#123;&#125;);  // functionconsole.log(typeof /1234/);  // object，正規表達式也是物件型別\n\n觀察上方 typeof 程式碼，你就會發現 null 和 function 怪怪的，怎麼不是顯示我們預期的 null 跟 object\n\nnull\ntypeof null 為什麼是 object？ 其實它是一個過去就存在的 bug，曾經也有被討論要修改，但考慮到這會影響太多舊有的程式，所以就不修改了\n產生這個 bug 的原因，簡單來說就是在 JavaScript 初期的實作中，JavaScript 的值是由一個表示「型別」的標籤，與實際內容的「值」所組合成的\n但是由於物件 ( Object ) 這個型別的標籤是「0」，而且 null 代表的是空值 ( NULL pointer，慣例上會以 0x00 來表示 )，於是代表 null 的標籤與物件的標籤搞混了，就產生了這樣的錯誤結果\n如果想了解更多 typeof null 的內容可以參考這篇文章：Null and typeof\n\nfunction\n再來說說函式，嚴格來說「函式是一個函式物件」，typeof function()&#123; &#125; 回傳的是 function，但實際上仍然是屬於「物件型別」，前面也驗證過物件型別能新增屬性，而函式也可以，只是與一般物件不同的是，函式多了可以被呼叫 ( be invoked ) 的功能\n而 ECMAScript 對於 function 的定義也可以作為參考\n\n\n\n原始型別包裹物件之後的文章會介紹一些型別轉換的內容，而其中會需要一些「原始型別包裹物件」( Primitive Wrapper Objects ) 的相關知識，所以加入在本篇文章介紹，原始型別中除了 undefined、null 之外，每個型別都有各自可以使用的方法 ( undefined、null 型別沒有包裹物件 )\n如下範例，字串型別可以使用 toUpperCase 方法，將字串字母都轉為大寫，數值型別卻無法使用，可是字串是純值，不是物件、也不是函式，toUpperCase 方法又是從哪裡來的呢？\nlet str = &#x27;i am amy&#x27;;console.log(str.toUpperCase());  // I AM AMY\n\n// 數值型別沒有 toUpperCase 這個方法，試圖使用會跳出錯誤let num = 1;console.log(num.toUpperCase());  // Uncaught TypeError: num.toUpperCase is not a function\n\n原始型別的方法來自於「原始型別包裹物件」，建立一個純值時，就會套用與該值型別對應的包裹物件，因此純值就能使用包裹物件中的方法了\n以剛剛的 toUpperCase 方法為例，就可以在 String 包裹物件中找到這個方法，使用 console.dir 印出 String 這個包裹物件，展開一個叫 prototype 的物件\n\n往下尋找就可以找到 String 包裹物件中的 toUpperCase 方法\n\n同理，數值和布林型別也有各自的包裹物件：Number、Boolean，同樣也可以試著用 console.dir(Number); 查看數值型別的包裹物件中有哪些方法，這邊就交給大家嘗試做做看囉 ~\n原始型別包裹物件可用來轉換型別而包裹物件其實也是一個可以被直接呼叫的函式，實戰中也會使用它來做型別的轉換，如以下範例，String 作為函式可以將傳入的值轉換成字串型別的值，所以轉型後的值能使用 String 中的 length 方法來查看字串的長度\nconst str = String(123);console.log(str.length);  // 3\n\n不要把原始型別包裹物件作為函式建構子使用以 String 來說，雖然可以使用 new 運算子來建構「字串」，但是這會造成所謂的「字串」變成物件，而這個物件會同時包含包裹物件的所有方法\n直接看看用 new 運算子結合 String 包裹物件建立字串，會發生什麼事：印出結果都會明示或暗示你，你建立的字串變成物件了，所以要避免用這種方式來建立原始型別的值\nlet str = new String(&#x27;I am Amy&#x27;);  // str 會是一個物件let str2 = new String(&#x27;I am Amy&#x27;);  // str2 會是另一個物件console.log(typeof str);  // objectconsole.log(str == str2);  // falsestr.myName = &#x27;我是字串&#x27;;console.log(str);  // String &#123;&#x27;I am Amy&#x27;, myName: &#x27;我是字串&#x27;&#125;console.log(str2);  // String &#123;&#x27;I am Amy&#x27;&#125;\n\n📎補充：BigInt、Symbol 僅能作為函式，無法作為函式建構子使用，若試圖這樣做，會跳出 TypeError 的錯誤如下圖\n\n結語本篇文章簡單介紹了強型別與弱型別的基本概念，以及 JavaScript 中型別有哪些、型別判斷的方式和 typeof 的例外，最後介紹一些與原始型別包裹物件有關的內容，原始型別包裹物件在後面的文章也會出現，本篇文章算是建立一些基本知識，為接下來會往下介紹型別轉換時做鋪墊\n那我們就下篇文章見囉 ~\n","categories":["JavaScript"],"tags":["前端","JavaScript"]}]